<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MongoDB干货篇之更新数据]]></title>
      <url>%2F2017%2F05%2F01%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之数据更新常用的函数 update(&lt;query&gt;,&lt;update&gt;,&lt;upsert&gt;,&lt;multi&gt;),其中&lt;query&gt;表示筛选的条件，&lt;update&gt;是要更新的数据 updateMany() 更新所有匹配到的数据 upsert upsert是一个布尔类型的数据，如果为true时，当根据query条件没有找到匹配的数据时，就表示插入此条数据，如果为false就表示不插入数据 下面将会在一个空的集合中更新数据1234567//就会插入此条数据，因为没有找到匹配的信息db.user.update(&#123;'name':'chenjiabing','age':22,'sex':"Man"&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;,&#123;'upsert':true&#125;); db.user.update(&#123;'name':'chenjiabing','age':22,'sex':"Man"&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;,true); //和上面的语句等价//输出 db.user.find()&#123; "_id" : ObjectId("59067b70856d5893a687655f"), "age" : 22, "name" : "chenjiabing", "sex" : "Man", "hobby" : "read" &#125; multi 如果这个参数为true,就把按条件查出来多条记录全部更新。默认为false,如果为true的话和updateMany()一样的效果 下面将会更新所有匹配到的数据 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$set:&#123;'hobby':'code'&#125;&#125;,&#123;'multi':true&#125;); 字段更新操作符 Field Update Operators$set $set用来指定一个键的值。如果这个键不存在，则创建它。注意这里的更新默认是只更新第一条匹配到的数据，如果第一条匹配的数据已经满足修改后的条件，那么将不会执行下面匹配的信息 下面我们将会添加一条信息在数据库中 1db.user.insert(&#123;"name":'jack',"age":22,"sex":'Man','school':&#123;'name':'jsnu','city':'xuzhou'&#125;&#125;); 运行下面的代码，将该用户的兴趣设置为“读书”并添加至文档中(此时文档中hobby键是不存在，该条文档就会创建它) 1db.user.update(&#123;name:'jack'&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;) 下面将会修改用户的年龄 1db.user.update(&#123;'name':'jack'&#125;,&#123;$set:&#123;'age':20&#125;&#125;) 下面用$set修改数据类型，将sex设置为1 1db.user.update(&#123;'name':'jack'&#125;,&#123;$set:&#123;'sex':1&#125;&#125;) 下面用$set修改内嵌文档，必须指定文档的名字和键值 1db.user.update(&#123;name:'jack'&#125;,&#123;$set:&#123;'school.name':'shida','school.city':'beijing'&#125;&#125;) $unset 从文档中移除指定的键 下面将要删除上面插入的hobby键 1db.user.update(&#123;name:'jack'&#125;,&#123;$unset:&#123;'hobby':1&#125;&#125;) //这里的值是任意给的，随便什么值 $inc $inc修改器用来增加已有键的值，或者在键不存在时创建一个键$inc就是专门来增加（和减少）数字的。$inc只能用于整数、长整数或双精度浮点数。要是用在其他类型的数据上就会导致操作失败 例如毎次有人访问该博文，该条博文的浏览数就加1，用键pageViews保存浏览数信息。这个键值上面没有定义过，所以会自动创建一个 1db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;'pageViews':1&#125;&#125;); //起初没有就会自动创建一个键 下面演示增加和减少 123db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;'pageViews':100&#125;&#125;) ; //这里是在上面的基础上加上100，此时变成了101db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;"pageViews":-100&#125;&#125;) ; //这里是在上面的基础上减去100,此时还是变成了1 $rename 语法：{$rename: { &lt;old name1&gt;: &lt;new name1&gt;, &lt;old name2&gt;: &lt;new name2&gt;, ... } } $rename操作符可以重命名字段名称，新的字段名称不能和文档中现有的字段名相同。 下面重新插入一条数据，并且改变这条数据的键的名称 123db.user.insert(&#123;name:'chenjiabing','age':22,'sex':'Man','school':&#123;'name':'jsnu','city':'beijing'&#125;&#125;);db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'age':'Age'&#125;&#125;) //重命名age为Age 下面将要演示怎样改变内嵌文档的键的名称，注意一定要带上文档的名字 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'school.name':'school.Name','school.city':'school.City'&#125;&#125;); 如果重命名的字段字和集合中原有的字段名字相同的话就会覆盖原有的字段名称，那么就会造成数据的丢失 1234567db.user.update(&#123;name:'chenjiabing'&#125;,&#123;'$rename':&#123;'sex','age'&#125;&#125;); //这里sex变成age和原来的age相同，那么原来的age就会丢失db.user.find(&#123;name:'chenjiabing'&#125;); //输出，可以看到原来的age没有了,变成了覆盖之后的&#123; "_id" : ObjectId("590674ce30b9f88dd43d7ee4"), "name" : "chenjiabing", "age" : "Man", "school" : &#123; "name" : "jsnu", "city" : "beijing" &#125; &#125; 如果指定的字段不存在，那么将不会更新，对原来的字段没有影响 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;value:'name'&#125;&#125;); //将不会有任何的改变，因为value这个字段根本不存在 $rename操作符也可以将子文档中键值移到其他子文档中 12345db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'school.name':'contact.name'&#125;&#125;);// 这里将会将school.name这个字段的值移到contact.name之中，如果contact不存在，那么就会创建一个//输出&#123; "_id" : ObjectId("590674ce30b9f88dd43d7ee4"), "name" : "chenjiabing", "age" : "Man", "school" : &#123; "city" : "beijing" &#125;, "contact" : &#123; "name" : "jsnu" &#125; &#125; 数组更新操作符 Array Update Operators 只能用在键值为数组的键上的数组操作。 $ (query) 语法:{ &quot;&lt;array&gt;.$&quot; : value } 当对数组字段进行更新时，且没有明确指定的元素在数组中的位置，我们使用定位操作符$标识一个元素，数字都是以0开始的。 注意: 定位操作符(“$”)作为第一个匹配查询条件的元素的占位符，也就是在数组中的索引值。 数组字段必须出现查询文档中。 向集合中插入两条数据 12db.students.insert(&#123; "_id" : 1, "grades" : [ 78, 88, 88 ] &#125;);db.students.insert(&#123; "_id" : 2, "grades" : [ 88, 90, 92 ] &#125;); 执行下列操作 1234//查询匹配的文档中，数组有2个88，只更新第一个匹配的元素，也就是"grades.1"db.students.update( &#123; _id: 1, grades: 88 &#125;, &#123; $set: &#123; "grades.$" : 82 &#125; &#125;) ;//查询文档中没有出现grades字段，查询报错db.students.update( &#123; _id: 2 &#125;, &#123; $set: &#123; "grades.$" : 82 &#125; &#125; ); $push 如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组。 下面我们将使用$push对该文档添加一条评论信息。 1234567//将会创建一个comments数组，因为一开始这个数组没有存在db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$push:&#123;comments:&#123;'name':'jack','content':'hello thanks'&#125;&#125;&#125;)//继续添加一条，在comments的末尾进行添加，此时comments变成两条数据了db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$push:&#123;comments:&#123;'name':'john','content':'hello'&#125;&#125;&#125;) $pull 语法：db.collection.update( { field: &lt;query&gt; }, { $pull: { field: &lt;query&gt; } } ); $pull操作符移除指定字段值为数组，且匹配$pull操作符移除指定字段值为数组，且匹配$pull语句声明的查询条件的所有元素。 执行如下操作 123456789101112//插入一条文档db.profiles.insert(&#123; votes: [ 3, 5, 6, 7, 7, 8 ] &#125;);//移除数组中所有元素7db.profiles.update( &#123; votes: 3 &#125;, &#123; $pull: &#123; votes: 7 &#125; &#125; );//移除数组中所有大于6的元素db.profiles.update( &#123; votes: 3 &#125;, &#123; $pull: &#123; votes: &#123; $gt: 6 &#125; &#125; &#125; );//Result&#123; votes: [ 3, 5, 6, 8 ] &#125;&#123; votes: [ 3, 5, 6 ] &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之查询数据]]></title>
      <url>%2F2017%2F04%2F30%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之查询准备工作 在开始之前我们应该先准备数据方便演示，这里我插入的了几条数据，数据如下：12345678910111213141516171819202122232425262728293031323334db.user.insertMany([&#123;name:'jack',age:22,sex:'Man',tags:['python','c++','c'],grades:[22,33,44,55],school:&#123;name:'shida',city:'xuzhou'&#125;&#125;,&#123;name:'jhon',age:33,sex:null,tags:['python','java'],grades:[66,22,44,88],school:&#123;name:'kuangda',city:'xuzhou'&#125;&#125;,&#123;name:'xiaoming',age:33,tags:['python','java'],grades:[66,22,44,88],school:&#123;name:'kuangda',city:'xuzhou'&#125;&#125;]) find() 其中query表示查找的条件，相当于mysql中where子句,projection列出你想要查找的数据，格式为db.collection.find(find(&lt;query filter&gt;, &lt;projection&gt;)) 实例： 下面不带参数的查找，将会查找出所有的结果 12345678910111213141516171819202122232425 db.find().pretty(); //输出结果 &#123; &quot;_id&quot; : ObjectId(&quot;59056f81299fe049404b2899&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 22, &quot;tags&quot; : [ &quot;python&quot;, &quot;c++&quot;, &quot;c&quot; ], &quot;grades&quot; : [ 22, 33, 44, 55 ], &quot;school&quot; : &#123; &quot;name&quot; : &quot;shida&quot;, &quot;city&quot; : &quot;xuzhou&quot; &#125; &#125; 下面找出满足name为jack的数据，并且只输出name,age,这里的_id是默认输出的，如果不想输出将将它设置为0，想要输出那个字段将它设置为1 12345678910db.user.find(&#123;name:'jack'&#125;,&#123;name:1,age:1&#125;)//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22 &#125;db.user.find(&#123;name:'jack'&#125;,&#123;name:1,age:1，_id:0&#125;)//输出结果&#123;"name" : "jack", "age" : 22 &#125; **注意这里的一个 projection不能 同时 指定包括和排除字段，除了排除 _id字段。 在 显式包括 字段的映射中，_id 字段是唯一一个您可以 显式排除 的。 查询内嵌文档 上述例子中插入的school数据就表示内嵌文档 完全匹配查询 完全匹配查询表示school中的查询数组必须和插入的数组完全一样，顺序都必须一样才能查找出来 1234567891011db.user.find(&#123;name:'jack',school:&#123;name:'shida',city:'xuzhou'&#125;&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;//下面是指定输出的字段，这里的school.name表示只输出school文档中name字段，必须加引号db.user.find(&#123;name:'jack',school:&#123;name:'shida',city:'xuzhou'&#125;&#125;,&#123;name:1,age:1,'school.name':1&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "school" : &#123; "name" : "shida" &#125; &#125; 键值对查询 可以通过键值对查询，不用考虑顺序，比如&#39;school.name&#39;:&#39;shida&#39;，表示查询学校名字为shida的数据，这里的引号是必须要的 12345db.user.find(&#123;'school.name':'shida'&#125;,&#123;name:1,school:1&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; 查询操作符 下面我们将配合查询操作符来执行复杂的查询操作，比如元素查询、 逻辑查询 、比较查询操作。我们使用下面的比较操作符&quot;$gt&quot; 、&quot;$gte&quot;、 &quot;$lt&quot;、 &quot;$lte&quot;(分别对应&quot;&gt;&quot;、 &quot;&gt;=&quot; 、&quot;&lt;&quot; 、&quot;&lt;=&quot;) 实例 下面查询年龄在20-30之间的信息 123456db.user.find(&#123;age:&#123;$gt:20,$lt:30&#125; &#125;)//输出&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $ne $ne表示不相等，例如查询年龄不等于22岁的信息 1234db.user.find(&#123;age:&#123;$ne:22&#125;&#125;)//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31e0"), "name" : "jhon", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; slice $slice操作符控制查询返回的数组中元素的个数。此操作符根据参数{ field: value } 指定键名和键值选择出文档集合，并且该文档集合中指定array键将返回从指定数量的元素。如果count的值大于数组中元素的数量，该查询返回数组中的所有元素的。 语法：db.collection.find( { field: value }, { array: {$slice: count }}); 下面将查询grades中的前两个数 12345db.user.find(&#123;name:'jack'&#125;,&#123;grades:&#123;$slice:2&#125;,name:1,age:1,'school.name':1&#125;);//输出，可以看出这里的grades只输出了前面两个&#123; "_id" : ObjectId("59057c16f551d8c9003d31df"), "name" : "jack", "age" : 22, "grades" : [ 22, 33 ], "school" : &#123; "name" : "shida" &#125; &#125; 下面将输出后3个数据 1234db.user.find(&#123;name:'jhon'&#125;,&#123;grades:&#123;$slice:-3&#125;,name:1&#125;);//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31e0"), "name" : "jhon", "grades" : [ 22, 44, 88 ] &#125; 下面介绍指定一个数组作为参数。数组参数使用[ skip , limit ] 格式，其中第一个值表示在数组中跳过的项目数,第二个值表示返回的项目数。 123456db.user.find(&#123;name:'jack'&#125;,&#123;grades:&#123;$slice:[2,2]&#125;,name:1&#125;); //这里将会跳过前面的两个，直接得到后面的两个数据//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31df"), "name" : "jack", "grades" : [ 44, 55 ] &#125; $exists 如果$exists的值为true,选择存在该字段的文档,若值为false则选择不包含该字段的文档 下面将会查询不存在sex这一项的信息 1234567891011db.user.find(&#123;sex:&#123;$exists:false&#125;&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;db.user.find(&#123;sex:&#123;$exists:true&#125;&#125;);//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; $or 执行逻辑OR运算,指定一个至少包含两个表达式的数组，选择出至少满足数组中一条表达式的文档。语法：{ $or: [ { &lt;expression1&gt; }, { &lt;expression2&gt; }, ... , { &lt;expressionN&gt; } ] } 下面将要查找age等于22或者age等于33的值 1234567db.user.find(&#123;$or:[&#123;age:22&#125;,&#123;age:33&#125;]&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; 下面将会查找出年龄为22或者33并且姓名为jack的人的信息 12345db.user.find(&#123;name:'jack',$or:[&#123;age:33&#125;,&#123;age:22&#125;]&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $and 指定一个至少包含两个表达式的数组，选择出满足该数组中所有表达式的文档。$and操作符使用短路操作，若第一个表达式的值为“false”,余下的表达式将不会执行。语法：{ $and: [ { &lt;expression1&gt; }, { &lt;expression2&gt; } , ... , { &lt;expressionN&gt; } ] } 下面将会查找年龄在20-30之间的信息，对于下面使用逗号分隔符的表达式列表，MongoDB会提供一个隐式的$and操作： 12345db.user.find(&#123;$and:[&#123;age:&#123;$gt:20&#125;&#125;,&#123;age:&#123;$lt:30&#125;&#125;]&#125;)//上述语句相当于db.user.find(&#123;age:&#123;$gt:20&#125;,age:&#123;$lt:30&#125;&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $in 匹配键值等于指定数组中任意值的文档。类似sql中in，只要匹配一个value就会输出语法：{ field: { $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] } } 下面将会查找grades中存在22,33之间的任意一个数的信息 1234567 db.user.find(&#123;grades:&#123;$in:[22,33]&#125;&#125;) //输出 &#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; $nin 匹配键不存在或者键值不等于指定数组的任意值的文档。类似sql中not in(SQL中字段不存在使用会有语法错误). 查询出grades中不存在100或者44的文档 1db.user.find(&#123;grades:&#123;$nin:[100,44]&#125;&#125;) $not 执行逻辑NOT运算，选择出不能匹配表达式的文档 ，包括没有指定键的文档。$not操作符不能独立使用，必须跟其他操作一起使用 语法:{ field: { $not: { } } } 查询年龄不大于30的信息 1234db.user.find(&#123;age:&#123;$not:&#123;$gt:30&#125;&#125;&#125;)//输出&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; 迭代游标的查询 学过高级语言的朋友都知道迭代的问题，像java,下面使用迭代的方法查询 1234567891011121314151617var cursor=db.usr.find();//这里使用迭代输出所有的数据while(cursor.hasNext()) //这里的hasNext()是判断是否下一个中还有可迭代的值，如果没有返回false&#123; printjson(cursor.next()); //这里的cursor.next是迭代的输出，printjson是代替print(tojson()) &#125;print cursor.count() //输出其中有多少个数据cursor.forEach(printjson); //forEach输出var document=cursor.toArray(); //将迭代对象转换成数组print document[0]; //以数组的形式输出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫之BeautifulSoup]]></title>
      <url>%2F2017%2F04%2F29%2Fpython%E7%88%AC%E8%99%AB%E4%B9%8BBeautifulSoup%2F</url>
      <content type="text"><![CDATA[python爬虫之BeautifulSoup简介 Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 安装 pip install BeautifulSoup4 easy_install BeautifulSoup4 创建BeautifulSoup对象 首先应该导入BeautifulSoup类库 from bs4 import BeautifulSoup 下面开始创建对像，在开始之前为了方便演示，先创建一个html文本，如下： 1234567891011html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;""" 创建对象：soup=BeautifulSoup(html,&#39;lxml&#39;),这里的lxml是解析的类库，目前来说个人觉得最好的解析器了，一直在用这个，安装方法：pip install lxml Tag Tag就是html中的一个标签，用BeautifulSoup就能解析出来Tag的具体内容，具体的格式为soup.name,其中name是html下的标签，具体实例如下： print soup.title输出title标签下的内容，包括此标签，这个将会输出&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt; print soup.head 注意： 这里的格式只能获取这些标签的第一个，后面会讲到获取多个标签的方法。其中对于Tag有两个重要的属性name和attrs,分别表示名字和属性,介绍如下： name:对于Tag，它的name就是其本身，如soup.p.name就是p attrs是一个字典类型的，对应的是属性-值，如print soup.p.attrs,输出的就是{&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;},当然你也可以得到具体的值，如print soup.p.attrs[&#39;class&#39;],输出的就是[title]是一个列表的类型，因为一个属性可能对应多个值,当然你也可以通过get方法得到属性的，如：print soup.p.get(&#39;class&#39;)。还可以直接使用print soup.p[&#39;class&#39;] get get方法用于得到标签下的属性值，注意这是一个重要的方法，在许多场合都能用到，比如你要得到&lt;img src=&quot;#&quot;&gt;标签下的图像url,那么就可以用soup.img.get(&#39;src&#39;),具体解析如下： 1print soup.p.get("class") #得到第一个p标签下的src属性 string 得到标签下的文本内容，只有在此标签下没有子标签，或者只有一个子标签的情况下才能返回其中的内容，否则返回的是None具体实例如下： 123print soup.p.string #在上面的一段文本中p标签没有子标签，因此能够正确返回文本的内容print soup.html.string #这里得到的就是None,因为这里的html中有很多的子标签 get_text() 可以获得一个标签中的所有文本内容，包括子孙节点的内容，这是最常用的方法 搜索文档树find_all( name , attrs , recursive , text , **kwargs ) find_all是用于搜索节点中所有符合过滤条件的节点 1.name参数：是Tag的名字，如p,div,title ….. soup.find_all(&quot;p&quot;) 查找所有的p标签，返回的是[&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]，可以通过遍历获取每一个节点，如下： 123ps=soup.find_all("p")for p in ps: print p.get('class') #得到p标签下的class属性 传入正则表达式：soup.find_all(re.compile(r&#39;^b&#39;)查找以b开头的所有标签，这里的body和b标签都会被查到 传入类列表：如果传入列表参数,BeautifulSoup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签 1soup.find_all(["a", "b"]) 2.KeyWords参数，就是传入属性和对应的属性值，或者一些其他的表达式 soup.find_all(id=&#39;link2&#39;),这个将会搜索找到所有的id属性为link2的标签。传入正则表达式soup.find_all(href=re.compile(&quot;elsie&quot;)),这个将会查找所有href属性满足正则表达式的标签 传入多个值：soup.find_all(id=&#39;link2&#39;,class_=&#39;title&#39;) ,这个将会查找到同时满足这两个属性的标签，这里的class必须用class_传入参数，因为class是python中的关键词 有些属性不能通过以上方法直接搜索，比如html5中的data-*属性，不过可以通过attrs参数指定一个字典参数来搜索包含特殊属性的标签，如下： 1234# [&lt;div data-foo="value"&gt;foo!&lt;/div&gt;]data_soup.find_all(attrs=&#123;"data-foo": "value"&#125;) #注意这里的atts不仅能够搜索特殊属性，亦可以搜索普通属性soup.find_all("p",attrs=&#123;'class':'title','id':'value'&#125;) #相当与soup.find_all('p',class_='title',id='value') 3.text参数：通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True12345678soup.find_all(text="Elsie")# [u'Elsie'] soup.find_all(text=["Tillie", "Elsie", "Lacie"])# [u'Elsie', u'Lacie', u'Tillie'] soup.find_all(text=re.compile("Dormouse"))[u"The Dormouse's story", u"The Dormouse's story"] 4.limit参数：find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果. 文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量,代码如下： 123soup.find_all("a", limit=2)# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] 5.recursive 参数:调用tag的 find_all() 方法时,BeautifulSoup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False find( name , attrs , recursive , text , **kwargs ) 它与 find_all() 方法唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果,就是直接返回第一匹配到的元素，不是列表，不用遍历，如soup.find(&quot;p&quot;).get(&quot;class&quot;) css选择器 我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加#，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 soup.select()，返回类型是 list 通过标签名查找123456print soup.select('title') #[&lt;title&gt;The Dormouse's story&lt;/title&gt;]print soup.select('a')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过类名查找12print soup.select('.sister')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过id名查找12print soup.select('#link1')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 组合查找 学过css的都知道css选择器，如p #link1是查找p标签下的id属性为link1的标签 12345print soup.select('p #link1') #查找p标签中内容为id属性为link1的标签#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]print soup.select("head &gt; title") #直接查找子标签#[&lt;title&gt;The Dormouse's story&lt;/title&gt;] 属性查找 查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。 123456print soup.select('a[class="sister"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]print soup.select('a[href="http://example.com/elsie"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 同样，属性仍然可以与上述查找方式组合，不在同一节点的空格隔开，同一节点的不加空格,代码如下： 12print soup.select('p a[href="http://example.com/elsie"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容 1234567soup = BeautifulSoup(html, 'lxml')print type(soup.select('title'))print soup.select('title')[0].get_text()for title in soup.select('title'): print title.get_text() 参考文章 中文文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之安装]]></title>
      <url>%2F2017%2F04%2F28%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之安装安装 下载地址 点击安装,选择自定义，后选择安装路径，不过最好安装在根目录下(C盘)，然后点解next,这里我安装的路径是C:\MongoDB 创建文件夹:在C:\MongoDB下创建一个文件夹data,然后在data文件夹下创建db,log两个子文件夹,在log文件下创建一个MongoDB.log文档，总得来说创建了C:\MongoDB\data,C:\MongoDB\data\db,C:\MongoDB\data\log,C:\MongoDB\data\log\MongoDB.log 在C:\MongoDB\bin文件夹下运行cmd.exe进入dos命令，执行以下命令： 然后在cmd下输入mongod -dbpath &quot;C:\MongoDB\data\db,将会看到一些信息，说明已经安装成功了 测试连接 在C:\MongoDB\bin文件夹下运行cmd.exe,输入mongo或者mongo.exe,将会出现连接的信息，说明已经连接成功了 然后在另外一个cmd.exe在bin目录下运行mongo可以看到已经连接上MongoDB了，注意上面打开的终端不能关闭，否则不能成功连接，这是比较麻烦的，需要每次连接都要启动，下面我们需要把它安装为windows服务 安装程windows服务注意在管理员的cmd.exe中运行以下命令，否则在MongoDB.log文件里出现遭到拒绝 运行cmd，进入bin目录，执行以下命令: mongod --dbpath &quot;C:\MongoDB\data\db&quot; --logpath &quot;D:\MongoDB\data\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;,这里的服务名为MongoDB，可以在C:\MongoDB\data\log\MongoDB.log文件里查看相关信息，如果出现遭到拒绝就是没有在管理员的权限下执行命令 接下来就是启动服务了，现在在cmd.exe中运行NET START MongoDB，如果看到服务成功启动，那么就成功了，但是我在启动的时候出现48错误，下面将会做出解决方法： 先删除服务:mongod --dbpath &quot;C:\MongoDB\data\db&quot; --logpath &quot;C:\MongoDB\data\log\MongoDB.log&quot; --remove --serviceName &quot;MongoDB&quot; 删除MongoDB目录下的mongod.lock 然后就是重新安装了,执行以下命令： mongod --logpath &quot;C:\MongoDB\data\log\MongoDB.log&quot; --logappend --dbpath &quot;C:\Mongodb\data&quot; --directoryperdb --serviceName &quot;MongoDB&quot; --serviceDisplayName &quot;MongoDB&quot; --install 接下来重新启动服务，net start MongoDB,可以看到成功启动了 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC干货篇一]]></title>
      <url>%2F2017%2F04%2F27%2FJDBC%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%80%2F</url>
      <content type="text"><![CDATA[JDBC干货篇一JDBC基础 JDBC的全称是Java Database Connectivity，即Java数据库连接，它是一种可以执行SQL语句的Java API。程序可通过JDBC API连接到关系数据库，并使用结构化查询语言（SQL，数据库标准的查询语言）来完成对数据库的查询、更新 与其他数据库编程环境相比，JDBC为数据库开发提供了标准的API，使用JDBC开发的数据库应用可以跨平台运行，而且还可以跨数据库（如果全部使用标准的SQL语句）。也就是说如果使用JDBC开发一个数据库应用，则该应用既可以在Windows操作系统上运行，又可以在Unix等其他操作系统上运行，既可以使用MySQL数据库，又可以使用Oracle等其他的数据库，应用程序不需要做任何的修改 加载数据库驱动 Class.forName(classDriver)其中classDriver就是数据库驱动类对应的字符串,下面给出加载mysql,oracle数据库的例子： 12Class.forName("com.mysql.jdbc.Driver"); //mysqlClass.forName("oracle.jabc.driver.OracleDriver"); //oracle 获取数据库连接获得数据库连接的方法为DriverManager.getConnection(),其中有不同的参数，也对应不同的方法，下面将会详细介绍 DriverManager.getConnection(String url) DriverManager.getConnection(String url, Properties prop) 这里的Properties是一个属性集，详情请看文档 DriverManager.getConnection(String url,String user,String password) 这里的url是jdbc:mysql://localhost:3306/java_demo，其中java_demo表示你自己创建的数据库名字，urser表示当前数据库的登录的用户名，password表示密码 12345678910111213//第二种方法String url="jdbc:mysql://localhost:3306/java_demo"; //这是连接的urlString user="root";String password="root"; Properties properties=new Properties(); //创建属性集properties.setProperty("password", password); //向起中添加属性,很想python中的字典properties.setProperty("user",user); Class.forName("com.mysql.jdbc.Driver"); //加载数据库驱动Connection conn=DriverManager.getConnection(url,properties); //连接数据库//第三种方法Connection conn=DriverManager.getConnection(url,user,password); //连接数据库 注意：以上只是一些例子，并不是完整的代码，其中并没有处理异常，还应该注意的是要关闭connection 查询数据 查询数据有两种方法，分别为静态查询和动态查询，静态查询使用的Statement，动态查询使用的PrepareStatement,下面详细介绍这两种查询方法 静态查询 使用的是Statement,其中常用的函数如下： boolean execute(String SQL) 如果ResultSet对象可以被检索，则返回的布尔值为true，否则返回 false 。当你需要使用真正的动态 SQL 时，可以使用这个方法来执行 SQL DDL 语句 int executeUpdate(String SQL) 返回执行 SQL 语句影响的行的数目。使用该方法来执行 SQL 语句，是希望得到一些受影响的行的数目，例如，INSERT，UPDATE 或 DELETE 语句 ResultSet executeQuery(String SQL): 返回一个 ResultSet 对象。当你希望得到一个结果集时使用该方法，就像你使用一个 SELECT 语句。 close()关闭statement对象，这个是必须有的，为了程序的安全，必须在结束之前关闭 实例： 1234567891011121314151617181920212223242526272829303132 Statement stmt = null; //申请对象try &#123; stmt = connection.createStatement( ); //通过Connection对象创建statement对象 String sql_1="select * from course;"; String sql_2="select * from course where id=2;"; ResultSet res_1=stm.executeQuery(sql_1); //执行查询语句，返回的是一个结果集合，上面已经说明了 ResultSet res_2=stm.executeQuery(sql_1); while(res_1.next()) &#123; System.out.println(res_1.getInt(1)+"---"+res_1.getString(2)); //分别查询第一列和第二列的值，通过列数查询 System.out.println(res_1.getInt("id")+"---"+res_1.getString("name")); //通过列名查询 &#125; &#125;catch (SQLException e) &#123; //捕捉异常 . . .&#125;finally &#123; if(connection!=null) &#123; connection.close(); //关闭连接 &#125; if(stmt!=null) &#123; stmt.close(); //关闭 &#125;&#125; 说明：ResultSet常用的方法如下：注意下面的方法会发生SQLException异常 public void beforeFirst() 将光标移动到第一行之前。 public void afterLast() 将光标移动到最后一行之后。 public boolean first() 将光标移动到第一行。从第一行的数据开始读取 public void last() 将光标移动到最后一行。 public boolean absolute(int row) 将光标移动到指定的第row行。 public boolean previous() 将光标移动到上一行，如果超过结果集的范围则返回false。 public boolean next() 将光标移动到下一行，如果是结果集的最后一行则返回 false。 public int getRow() 返回当前光标指向的行数的值。 public void moveToInsertRow() 将光标移动到结果集中指定的行，可以在数据库中插入新的一行。当前光标位置将被记住 public void moveToCurrentRow() 如果光标处于插入行，则将光标返回到当前行，其他情况下，这个方法不执行任何操作 public int getInt(String columnName)返回当前行中名为 columnName的列的 int 值。 public int getInt(int columnIndex) 返回当前行中指定列的索引的int值。列索引从 1 开始，意味着行中的第一列是1 ，第二列是 2 ，以此类推。 getString(int columIndex) 返回指定列的String类型的数据 getString(String columName) 返回当前行中名为columName的String类型的值 动态查询 动态查询使用的PrepareStatement这个类实现的，PreparedStatement 接口扩展了 Statement 接口，它让你用一个常用的 Statement 对象增加几个高级功能。这个 statement 对象可以提供灵活多变的动态参数 实例： 123456789101112131415161718192021222324252627282930PreparedStatement pstmt = null;try &#123; String SQL = "select * from course where age=? and name=?"; pstmt = conn.prepareStatement(SQL); //创建对象 pstmt.setInt(1,22); //设置参数age的值 ，1表示第一个参数 pstmt.setString(2,"chenjiabing"); //设置name的值，其中2表示第二个参数 ResultSet res=pstmt.execteQuery(); while(res.next) &#123; .... &#125; . . .&#125;catch (SQLException e) &#123; . . .&#125;finally &#123; if(connection!=null) &#123; connection.close(); &#125; if(pstmt!=null) &#123; pstmt.close(); //关闭 &#125; . . .&#125; 说明:JDBC 中所有的参数都被用?符号表示，这是已知的参数标记。在执行SQL 语句之前，你必须赋予每一个参数确切的数值。其中PrepareStatement的常用函数如下，当然Statement中的execute ,executeQuery,executeUpdate也可以使用 void setInt(int parameterIndex, int x) parameterIndex表示第几个?,这里的int x表示是mysql中定义的int类型的值 void setString(int parameterIndex,String x) 为第parameterIndex个String类型的?赋予x的值 其他的操作 这里还有delete,update,alter等一系列的操作都是和上面的一样，就是把sql语句改变以下，如果使用的是静态的就要为delete,update,使用Statement.execteUpdate(sql)这个函数,当然要使用动态的也是executeUpdate函数 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BootStrap干货篇之表单]]></title>
      <url>%2F2017%2F04%2F26%2FBootStrap%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[BootStrap干货篇之表单基本介绍 单独的表单控件会被自动赋予一些全局样式。所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;。 将 label元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。 基本实例： 1234567891011121314151617181920212223 &lt;div class=&apos;container&apos;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;File input&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;exampleInputFile&quot;&gt; &lt;p class=&quot;help-block&quot;&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; &lt;/div&gt; 说明：这里的form-control是对所有的输入控件而言的,源码中将width设置为100%，表示会将这个输入控件占满一整行，form-group是用来对label和input更好的排版的，其中还有form-group-sm,form-group-lg，源码中分别利用这个对带有form-control的控件设置了不同的高度，具体看源码，不过正常情况下还是使用form-group 内联表单 为 &lt;form&gt; 元素添加 .form-inline 类可使其内容左对齐并且表现为inline-block级别的控件。只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）从源码中可以看到对form-inline下的form-group,form-control,form-control-static,input-group,radio,checkbox都是用了display:inline-block 注意： 在 Bootstrap 中，输入框和单选/多选框控件默认被设置为 width: 100%; 宽度。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据你的布局需求，可能需要一些额外的定制化组件。 一定要有label标签，如果不想要label标签可以设置.sr-only将其隐藏如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 label 设置 .sr-only 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 aria-label、aria-labelledby或 title 属性。如果这些都不存在，屏幕阅读器可能会采取使用 placeholder 属性，如果存在的话，使用占位符来替代其他的标记，但要注意，这种方法是不妥当的。 实例: 1234567891011121314151617&lt;form class=&quot;form-inline&quot;&gt; &lt;!--指定了form-inline类--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!--label中的for标签是用于绑定组件的，如果指定了for标签，input中的id也和for标签的内容相同，那么就会当鼠标点击&lt;label&gt;内容时会自动聚焦在input上--&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputEmail3&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputPassword3&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt;&lt;/form&gt; 水平表单 水平表单通过指定为form指定form-horizontal类来设定，其中可以使用BootStrap的栅栏系统设置水平间距，其中的form-group的div就表示一行了，相当于&lt;div class=&#39;row&#39;&gt;&lt;/div&gt;,因此只需要在label和input中指定列就行了，但是input标签不能直接使用，要在外面加上div 实例： 12345678910111213141516171819202122232425262728&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!--相当与&lt;div class=&apos;row&apos;&gt;&lt;/div&gt;--&gt; &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 说明上面的label标签中的control-label主要的作用是设置文字的对齐方式为左对齐，如果不加这个将会在右边出现很大的空白 多选和单选框 多选框（checkbox）用于选择列表中的一个或多个选项，而单选框（radio）用于从多个选项中只选择一个。其中提供的类有checkbox,checkbox-inline,radio,radio-inline 内联单选和多选框 通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。 实例： 12345678910111213141516171819202122232425262728&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label for=&quot;sex&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label for=&quot;sex&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;男&lt;/label&gt; &lt;/div&gt; 不带label文本的Checkbox 和 radio 如果需要 &lt;label&gt; 内没有文字，输入框（input）正是你所期望的。 目前只适用于非内联的 checkbox和 radio。 请记住，仍然需要为使用辅助技术的用户提供某种形式的 label（例如，使用 aria-label）。 实例： 12345678910&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;blankCheckbox&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;blankRadio&quot; id=&quot;blankRadio1&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt; 下拉列表（select） 实例： 1234567&lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 静态控件 如果需要在表单中将一行纯文本和 label 元素放置于同一行，为&lt;p&gt;标签设置为form-control-static 实例： 1234567891011121314&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;p class=&quot;form-control-static&quot;&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 参考文章 中文官网 文档手册 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapyd部署爬虫]]></title>
      <url>%2F2017%2F04%2F24%2FScrapyd%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[Scrapyd部署爬虫准备工作 安装scrapyd: pip install scrapyd 安装scrapyd-client : pip install scrapyd-client 安装curl:[安装地址](http://ono60m7tl.bkt.clouddn.com/curl.exe),安装完成以后将所在目录配置到环境变量中 开始部署 修改scrapy项目目录下的scrapy.cfg文件，修改如下 123[deploy:JD_Spider] #加上target :nameurl = http://localhost:6800/ #将前面的#删除project = JD #project的名字，可以使用默认的，当然也可以改变 在任意目录下的打开终端，输入scrapyd,观察是否运行成功，运行成功的话，就可以打开http://localhost:6800看是否正常显示，如果正常显示则看到下面的这张图,这里的JD是部署之后才能看到的，现在是看不到的，所以没出现也不要担心： 在项目的根目录下运行如下的命令：python E:\python2.7\Scripts\scrapyd-deploy target -p project,这里的E:\python2.7\Scripts\是你的python安装目录，Scripts是安装目录下的一个文件夹，注意前面一定要加上python,target是在前面scrapy.cfg中设置的deploy:JD_Spider，JD_Spider就是target,project 是JD,因此这个完整的命令是python E:\python2.7\Scripts\scrapyd-deploy JD_Spider -p JD,现在项目就部署到上面了，这下网页上就有JD了，详情请见上图 验证是否成功，你可以在网页上看有没有显示你的工程名字，另外在根目录下输入python E:\python2.7\Scripts\scrapyd-deploy -l就能列出你所有部署过的项目了 启动爬虫：curl http://localhost:6800/schedule.json -d project=myproject -d spider=spider_name,这里的project填入的是项目名，spider_name填入的是你的爬虫中定义的name,运行我的实例完整的代码为：curl http://localhost:6800/schedule.json -d project=JD -d spider=spider，这里将会显示如下信息： 12#这里的jobid比较重要，下面会用到这个取消爬虫&#123;"status": "ok", "jobid": "3013f9d1283611e79a63acb57dec5d04", "node_name": "DESKTOP-L78TJQ7"&#125; 取消爬虫：curl http://localhost:6800/cancel.json -d project=myproject -d job=jobid,jobid就是上面的提到过的，如果取消我的这个实例代码如：curl http://localhost:6800/cancel.json -d project=JD -d job=3013f9d1283611e79a63acb57dec5d04,那么它的状态就会变成如下： 1&#123;"status": "ok", "prevstate": "running", "node_name": "DESKTOP-L78TJQ7"&#125; 列出项目：curl http://localhost:6800/listprojects.json,下面将会出现你已经部署的项目 删除项目：curl http://localhost:6800/delproject.json -d project=myproject 列出版本：curl http://localhost:6800/listversions.json?project=myproject,这里的project是项目的名字，是在scrapy.cfg设置的 列出爬虫：curl http://localhost:6800/listspiders.json?project=myproject这里的project是项目的名字，是在scrapy.cfg设置的 列出job:curl http://localhost:6800/listjobs.json?project=myproject这里的project是项目的名字，是在scrapy.cfg设置的 删除版本：curl http://localhost:6800/delversion.json -d project=myproject -d version=r99，这里的version是自己的项目版本号，在删除之前需要查看版本号 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy大战京东商城]]></title>
      <url>%2F2017%2F04%2F23%2Fscrapy%E5%A4%A7%E6%88%98%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[SCrapy爬虫大战京东商城引言 上一篇已经讲过怎样获取链接，怎样获得参数了，详情请看python爬取京东商城普通篇 代码详解 首先应该构造请求，这里使用scrapy.Request,这个方法默认调用的是start_urls构造请求，如果要改变默认的请求，那么必须重载该方法，这个方法的返回值必须是一个可迭代的对象，一般是用yield返回，代码如下： 12345def start_requests(self): for i in range(1,101): page=i*2-1 #这里是构造请求url的page,表示奇数 url=self.start_url+str(page) yield scrapy.Request(url,meta=&#123;'search_page':page+1&#125;,callback=self.parse_url) #这里使用meta想回调函数传入数据，回调函数使用response.meta['search-page']接受数据 下面就是解析网页了，从上面看出这里的解析回调函数是parse_url,因此在此函数中解析网页。这里还是和上面说的一样，这个url得到的仅仅是前一半的信息，如果想要得到后一半的信息还有再次请求，这里还有注意的就是一个技巧：一般先解析出一个数据的数组，不急着取出第一个数，先要用if语句判断，因为如果得到的是[]，那么直接取出[0]是会报错的，这只是一个避免报错的方法吧，代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def parse_url(self,response): if response.status==200: #判断是否请求成功 # print response.url pids = set() #这个集合用于过滤和保存得到的id,用于作为后面的ajax请求的url构成 try: all_goods = response.xpath("//div[@id='J_goodsList']/ul/li") #首先得到所有衣服的整个框架，然后从中抽取每一个框架 for goods in all_goods: #从中解析每一个 # scrapy.shell.inspect_response(response,self) #这是一个调试的方法，这里会直接打开调试模式 items = JdSpiderItem() #定义要抓取的数据 img_url_src = goods.xpath("div/div[1]/a/img/@src").extract() # 如果不存在就是一个空数组[]，因此不能在这里取[0] img_url_delay = goods.xpath( "div/div[1]/a/img/@data-lazy-img").extract() # 这个是没有加载出来的图片，这里不能写上数组取第一个[0] price = goods.xpath("div/div[3]/strong/i/text()").extract() #价格 cloths_name = goods.xpath("div/div[4]/a/em/text()").extract() shop_id = goods.xpath("div/div[7]/@ data-shopid").extract() cloths_url = goods.xpath("div/div[1]/a/@href").extract() person_number = goods.xpath("div/div[5]/strong/a/text()").extract() pid = goods.xpath("@data-pid").extract() # product_id=goods.xpath("@data-sku").extract() if pid: pids.add(pid[0]) if img_url_src: # 如果img_url_src存在 print img_url_src[0] items['img_url'] = img_url_src[0] if img_url_delay: # 如果到了没有加载完成的图片，就取这个url print img_url_delay[0] items['img_url'] = img_url_delay[0] # 这里如果数组不是空的，就能写了 if price: items['price'] = price[0] if cloths_name: items['cloths_name'] = cloths_name[0] if shop_id: items['shop_id'] = shop_id[0] shop_url = "https://mall.jd.com/index-" + str(shop_id[0]) + ".html" items['shop_url'] = shop_url if cloths_url: items['cloths_url'] = cloths_url[0] if person_number: items['person_number'] = person_number[0] # if product_id: # print "************************************csdjkvjfskvnk***********************" # print self.comments_url.format(str(product_id[0]),str(self.count)) # yield scrapy.Request(url=self.comments_url.format(str(product_id[0]),str(self.count)),callback=self.comments) #yield scrapy.Request写在这里就是每解析一个键裤子就会调用回调函数一次 yield items except Exception: print "********************************************ERROR**********************************************************************" yield scrapy.Request(url=self.search_url.format(str(response.meta['search_page']),",".join(pids)),callback=self.next_half_parse) #再次请求，这里是请求ajax加载的数据，必须放在这里，因为只有等到得到所有的pid才能构成这个请求，回调函数用于下面的解析 从上面代码的最后可以看出最后就是解析ajax加载的网页了，这里调用的next_half_parse函数，和解析前面一个网页一样，这里需要的注意的是，如果前面定义的数据没有搜索完毕是不能使用yield items的，必须将items通过meta传入下一个回调函数继续完善后才能yield items,这里就不需要了，代码如下： 12345678910111213141516171819202122232425262728293031323334353637#分析异步加载的网页 def next_half_parse(self,response): if response.status==200: print response.url items=JdSpiderItem() #scrapy.shell.inspect_response(response,self) #y用来调试的 try: lis=response.xpath("//li[@class='gl-item']") for li in lis: cloths_url=li.xpath("div/div[1]/a/@href").extract() img_url_1=li.xpath("div/div[1]/a/img/@src").extract() img_url_2=li.xpath("div/div[1]/a/img/@data-lazy-img").extract() cloths_name=li.xpath("div/div[4]/a/em/text()").extract() price=li.xpath("div/div[3]/strong/i/text()").extract() shop_id=li.xpath("div/div[7]/@data-shopid").extract() person_number=li.xpath("div/div[5]/strong/a/text()").extract() if cloths_url: print cloths_url[0] items['cloths_url']=cloths_url[0] if img_url_1: print img_url_1[0] items['img_url']=img_url_1 if img_url_2: print img_url_2[0] items['img_url']=img_url_2[0] if cloths_name: items['cloths_name']=cloths_name[0] if price: items['price']=price[0] if shop_id: items['shop_id']=shop_id[0] items['shop_url']="https://mall.jd.com/index-" + str(shop_id[0]) + ".html" if person_number: items['person_number']=person_number[0] yield items #又一次的生成，这里是完整的数据，因此可以yield items except Exception: print "**************************************************" 当然这里还用到了设置请求池，mysql存储，没有使用到ip代理，这个在我前面的博客中又讲到，这里就不再赘述了，想看源代码的朋友请点击这里 小技巧 人们会抱怨为什么自己的爬虫在中途断开就要重头开始爬，为什么不能从断开那里开始爬呢，这里提供一个方法：在配置文件settings.py中加入JOBDIR=file_name,这里的file_name是一个文件的名字 设置下载延迟防止被ban:DOWNLOAD_DELAY = 2:设置每一次的间隔时间 RANDOMIZE_DOWNLOAD_DELAY = True:这个是随机设置延迟时间 在设置的时间的0.5-1.5倍之间，这样可以更有效的防止被ban,一般是配套使用的 ROBOTSTXT_OBEY = False :这里是表示不遵循robots.txt文件，默认是True表示遵循，这里将之改成False CONCURRENT_REQUESTS :设置最大请求数，这里默认的时16，我们可以根据自己电脑的配置改的大一点来加快请求的速度 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫大战京东商城]]></title>
      <url>%2F2017%2F04%2F23%2Fpython%E7%88%AC%E8%99%AB%E5%A4%A7%E6%88%98%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[python大规模爬取京东主要工具 scrapy BeautifulSoup requests 分析步骤 打开京东首页，输入裤子将会看到页面跳转到了这里，这就是我们要分析的起点 我们可以看到这个页面并不是完全的，当我们往下拉的时候将会看到图片在不停的加载，这就是ajax,但是当我们下拉到底的时候就会看到整个页面加载了60条裤子的信息，我们打开chrome的调试工具，查找页面元素时可以看到每条裤子的信息都在&lt;li class=&#39;gl-item&#39;&gt;&lt;/li&gt;这个标签中，如下图： 接着我们打开网页源码就会发现其实网页源码只有前30条的数据，后面30条的数据找不到，因此这里就会想到ajax，一种异步加载的方式，于是我们就要开始抓包了，我们打开chrome按F12，点击上面的NetWork,然后点击XHR,这个比较容易好找,下面开始抓包，如下图： 从上面可以找到请求的url，发现有很长的一大段，我们试着去掉一些看看可不可以打开，简化之后的url=https://search.jd.com/s_new.php?keyword=%E8%A3%A4%E5%AD%90&amp;enc=utf-8&amp;qrst=1&amp;rt=1&amp;stop=1&amp;vt=2&amp;offset=3&amp;wq=%E8%A3%A4%E5%AD%90&amp;page={0}&amp;s=26&amp;scrolling=y&amp;pos=30&amp;show_items={1}这里的showitems是裤子的id,page是翻页的，可以看出来我们只需要改动两处就可以打开不同的网页了，这里的page很好找，你会发现一个很好玩的事情，就是主网页的page是奇数，但是异步加载的网页中的page是偶数，因此这里只要填上偶数就可以了，但是填奇数也是可以访问的。这里的show_items就是id了，我们可以在页面的源码中找到，通过查找可以看到id在li标签的data-pid中，详情请看下图 上面我们知道怎样找参数了，现在就可以撸代码了 代码讲解 首先我们要获取网页的源码，这里我用的requests库，安装方法为pip install requests，代码如下: 1234def get_html(self): res = requests.get(self.url, headers=self.headers) html = res.text return html #返回的源代码 根据上面的分析可以知道，第二步就是得到异步加载的url中的参数show_items,就是li标签中的data-pid,代码如下： 12345678def get_pids(self): html = self.get_html() soup = BeautifulSoup(html, 'lxml') #创建BeautifulSoup对象 lis = soup.find_all("li", class_='gl-item') #查找li标签 for li in lis: data_pid = li.get("data-pid") #得到li标签下的data-pid if (data_pid): self.pids.add(data_pid) #这里的self.pids是一个集合，用于过滤重复的 下面就是获取前30张图片的url了，也就是主网页上的图片，其中一个问题是img标签的属性并不是一样的，也就是源码中的img中不都是src属性，一开始已经加载出来的图片就是src属性，但是没有加载出来的图片是data-lazy-img，因此在解析页面的时候要加上讨论。代码如下： 12345678910111213141516def get_src_imgs_data(self): html = self.get_html() soup = BeautifulSoup(html, 'lxml') divs = soup.find_all("div", class_='p-img') # 图片 # divs_prices = soup.find_all("div", class_='p-price') #价格 for div in divs: img_1 = div.find("img").get('data-lazy-img') # 得到没有加载出来的url img_2 = div.find("img").get("src") # 得到已经加载出来的url if img_1: print img_1 self.sql.save_img(img_1) self.img_urls.add(img_1) if img_2: print img_2 self.sql.save_img(img_2) self.img_urls.add(img_2) 前三十张图片找到了，现在开始找后三十张图片了，当然是要请求那个异步加载的url，前面已经把需要的参数给找到了，下面就好办了，直接贴代码： 12345678910111213141516171819def get_extend_imgs_data(self): # self.search_urls=self.search_urls+','.join(self.pids) self.search_urls = self.search_urls.format(str(self.search_page), ','.join(self.pids)) #拼凑url,将获得的单数拼成url,其中show_items中的id是用','隔开的，因此要对集合中的每一个id分割，page就是偶数，这里直接用主网页的page加一就可以了 print self.search_urls html = requests.get(self.search_urls, headers=self.headers).text #请求 soup = BeautifulSoup(html, 'lxml') div_search = soup.find_all("div", class_='p-img') #解析 for div in div_search: img_3 = div.find("img").get('data-lazy-img') #这里可以看到分开查找img属性了 img_4 = div.find("img").get("src") if img_3: #如果是data-lazy-img print img_3 self.sql.save_img(img_3) #存储到数据库 self.img_urls.add(img_3) #用集合去重 if img_4: #如果是src属性 print img_4 self.sql.save_img(img_4) self.img_urls.add(img_4) 通过上面就可以爬取了，但是还是要考虑速度的问题，这里我用了多线程，直接每一页面开启一个线程，速度还是可以的，感觉这个速度还是可以的，几分钟解决问题，总共爬取了100个网页,这里的存储方式是mysql数据库存储的，要用发哦MySQLdb这个库，详情自己百度，当然也可以用mogodb但是还没有学呢，想要的源码的朋友请看GitHub源码 拓展写到这里可以看到搜索首页的网址中keyword和wq都是你输入的词，如果你想要爬取更多的信息，可以将这两个词改成你想要搜索的词即可，直接将汉字写上，在请求的时候会自动帮你编码的，我也试过了，可以抓取源码的，如果你想要不断的抓取，可以将要搜索的词写上文件里，然后从文件中读取就可以了。以上只是一个普通的爬虫，并没有用到什么框架，接下来将会写scrapy框架爬取的，请继续关注我的博客哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之处理元素]]></title>
      <url>%2F2017%2F04%2F22%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JQuery干货篇之处理元素 注意这里用的还是我前两篇用的例子，详情请看我的博客 attrattr() 方法设置或返回被选元素的属性值。 语法： $(selector).attr(attribute) 返回被选元素的属性值。 $(selector).attr(attribute,value) 设置被选元素的属性和值 $(selector).attr(attribute,function(index,oldvalue)) 设置被选元素的属性和值。 参数 描述 attribute 规定属性的名称。 function(index,oldvalue) 规定返回属性值的数。该函数可接收并使用选择器的 index 值和当前属性值。 实例：12345678910111213141516171819202122 $("img").filter(":first").attr('src'); //得到属性$("img").each(function (index,elem) &#123; if(index%2==0) $(elem).attr("src",'lily.png'); //设置属性 console.log($(elem).attr("src")); &#125;) $("img").attr('src',function (index,oldValue) &#123; //这里的oldValue表示原来属性的值，index是索引 if(oldValue=="rose.png") return 'lily.png'; else return 'astor.png'; &#125;) attrs=&#123; //使用映射对象一次设置多个值 src:'lily.png', style: 'border: thick double red' &#125;; $("img:eq(1)").attr(attrs); removeAttr removeAttr() 方法从被选元素中移除属性。 语法： $(selector).removeAttr(attribute) 这里的attribute是属性的名字 实例： 1$("img:first").removeAttr("src"); //删除属性src addClass addClass() 方法向被选元素添加一个或多个类 语法： $(selector).addClass(class) 这里的class是类名如果需要添加多个类，中间用空格隔开 $(selector).addClass(function(index,oldclass)) 这里的index是索引，oldClass是原来就有的类名，都是可选参数。这个函数的返回的就是要添加的类名 实例： 12345678910111213$("img:even").addClass("redBar"); //向偶数的img添加类redBar$("img").addClass(function (index,currentClass) &#123; //这里的currentClass就是原来有的类名，可选 if(index==1) return 'blueBar'; //第二个img应用blueBar这个类 else return 'redBar'; //这里需要注意的是，对同一个img应用类的时候，因为这个类的定义有优先级，上面定义会被后面定义的覆盖，所以要注意类定义的位置 &#125;) $("img").filter(":odd").addClass("redBar").end().filter(":even").addClass("blueBar"); //链式调用 $("img").addClass("blueBar redBar"); //添加两个类 hasClass hasClass() 方法检查被选元素是否包含指定的class 语法： $(selector).hasClass(class) //返回值是false和true 实例： 1console.log($("img:odd").hasClass("redBar")); toggleClass toggleClass() 对设置或移除被选元素的一个或多个类进行切换。该方法检查每个元素中指定的类。如果不存在则添加类，如果已设置则删除之。这就是所谓的切换效果 语法： $(selector).toggleClass(class,switch) class必需的，用来规定添加或移除class的指定元素，如需规定若干 class，请使用空格来分隔类名。switch是boolean可选参数，规定是否添加或移除class $(selector).toggleClass(function(index,class),switch) index表示索引，class表示选择器当前拥有的类 实例： 123456789101112131415161718192021222324$("img").toggleClass("redBar"); //这里对所有的img在redBar这个类之间切换$("img").toggleClass("redBar blueBar"); //在两个类之间来回的切换$("&lt;button&gt;ToggleClass&lt;/button&gt;").appendTo("#buttonDiv").click(function (e) &#123; $("img").toggleClass('redBar blueBar'); //在两种class之间切换，如果有就删除，没有的就添加 e.preventDefault(); &#125;) //下面添加一个按钮，完成同时添加多个图片的效果 $("&lt;button&gt;ToggleClass&lt;/button&gt;").appendTo("#buttonDiv").click(function (e) &#123; $("img").toggleClass(function (index,currentClass) &#123; if(index%2==0) return 'blueBar'; //动态的切换，这里是偶数就切换blue else return 'redBar blueBar'; //这里是奇数的图片在两种颜色来回的切换 &#125;); e.preventDefault(); &#125;) css css() 方法返回或设置匹配的元素的一个或多个样式属性，这里只说css，还有其他的设置css样式请看w3School 语法： $(selector).css(name) 返回第一个匹配元素的 CSS属性值。name是css属性的名称 $(selector).css(name,value) 设置所有匹配元素的指定 CSS 属性。name表示属性名称，value表示属性的值 $(selector).css(name,function(index,value)) 此函数返回要设置的属性值。接受两个参数，index为元素在对象集合中的索引位置，value 是原先的属性值。name表示要设置的属性名称，返回值就是要设置的属性值 实例： 1234567891011$("label").css('font-size','30px'); //设置字体大小$("label").css('font-size','+=10'); //使用相对值设置属性值，在原有的基础上加上10console.log($("h1").css('font-family')); //获取h1标签的字体var cssValues=&#123; 'border':'thick double red', 'font-size':'1.5em'&#125;;$("label").css(cssValues); //同时设置多个属性 text text() 方法方法设置或返回被选元素的文本内容。当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容(会删除 HTML 标记) 语法： $(selector).text() 当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容（会删除 HTML 标记）。 $(selector).text(content) 当该方法用于设置值时，它会覆盖被选元素的所有内容。 $(selector).text(function(index,oldcontent)) index表示索引,oldcontent表示选择器当前的文本内容 html html() 方法返回或设置被选元素的内容 (inner HTML)。如果该方法未设置参数，则返回被选元素的当前内容。 语法： $(selector).html() 当使用该方法返回一个值时，它会返回第一个匹配元素的内容。 $(selector).html(content) 当使用该方法设置一个值时，它会覆盖所有匹配元素的内容。 $(selector).html(function(index,oldcontent)) 使用函数来设置所有匹配元素的内容。index - 可选。接收选择器的index 位置,oldcontent - 可选。接收选择器的当前内容 val val() 方法返回或设置被选元素的值,元素的值是通过 value 属性设置的。该方法大多用于 input 元素,如果该方法未设置参数，则返回被选元素的当前值 语法： $(selector).val(value) 设置文本域的值为value $(selector).val() 得到文本域的值 $(selector).val(function(index,oldvalue)) 设置文本域的值，这里函数的返回值将会用来设置文本域的值，index表示元素索引，oldvalue表示选择器当前文本域的值 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之操控DOM]]></title>
      <url>%2F2017%2F04%2F21%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%93%8D%E6%8E%A7DOM%2F</url>
      <content type="text"><![CDATA[JQuery干货篇之插入元素本次使用的html,css还是我上一篇的源代码，详情请看上一篇文章 分类 插入子元素：append,prepend ,appendTo,prependTo 封装包裹元素：wrap,wrapAll,wrapInner 插入兄弟元素：after,before,insertAfter,insertBefore 替换元素：replaceWith,replaceAll 删除元素：remove,deatch,unwrap,empty 创建新元素通常在把新元素插入到DOM中的目标位置之前，要先创建一个新元素才能将它插入到指定位置 使用$创建元素 $(&lt;div&gt;&lt;img src=&#39;rose.png&#39; alt=&#39;玫瑰&#39;&gt;&lt;/div&gt;) clone 克隆元素，使用clone方法以已有的元素为模子生成新的元素，这个在后面的插入元素起到关键作用，如果在要引用html中的一个标签内容的话，不使用clone方法，那么就会将这段内容移动，因此这里使用clone会很方便，详细请看append的用法实例 实例： 1$("div.dcell").clone(); //这里的clone方法必须是JQuery对象调用 使用DOM API创建新元素 DOM API是用js操作的，其实jquery在幕后悄悄的调用DOM API 实例： 1234567891011121314 var divElem=document.createElement("div"); //创建一个div元素 divElem.classList.add("dcell"); //为div添加class=dcellvar imgElem=document.createElement("img");imgElem.src="lily.png";divElem.appendChild(imgElem); //在新创建的元素后面插入imgvar newElem=$(divElem);newElem.each(function (index,elem) &#123; console.log(elem.tagName+" "+elem.className);&#125;); append 把参数指定的元素插入到所有的JQuery内含元素内容末尾成为他们的最后一个子元素，形式有append(html),append(Jquery),append(HTMLElements[])，append(function()) 实例： 12345678910111213141516171819202122232425//这里使用append元素创建了一个div元素，在末尾插入元素成为div的子元素// var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;"); var newElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='lily.png'/&gt;") .append("&lt;label for='lily'&gt;Lily:&lt;/label&gt;") .append("&lt;input name='lily' value='0' required&gt;") .css("border", 'thick double red'); $("div.drow").append(orchildElems); //在末尾插入数据，这里的参数是jquery对象 $("div.drow").append(function(index,elem)&#123; if(elem.id=='row1') return orchildElems; else if(this.id='row2') return newElems; &#125;) $("div.drow").last().append(orchildElem,newElems); //在其中添加两个参数，插入的先后按照参数的先后位置，当然其中的参数个数没有限制 prepend 和append完全相反,向当前元素的前面插入html节点作为当前元素的子元素,形式有prepen d(Jquery),prepend(html),prepend(htmlElemnts[]),prepend(function()) 实例： 123456789101112131415161718 var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;");$("div.dcell").prepend(orchildElems); //将orchildElems插入到div.dcell的最前面，作为他的子元素$("div.dcell").prepend("&lt;img src='lily.png'&gt;"); //将参数html的内容插入到前面，作为子元素$("div.drow").append(function (index) &#123; //参数是函数，index是索引，返回的内容就是要插入到前面的内容 if (this.id == 'row1') return orchildElem; //返回的对象可以是jquery对象，也可以是html标签，如：return "&lt;img src='lily.png'&gt; else if (this.id = 'row2') return newElems; &#125;); appendTo appendTo是和append一样的函数，都是将指定的元素插入到指定元素的前面作为子元素，但是他们的参数就不同了，append是将指定的参数插入到当前调用它的的结果集中，而appendTo是将当前调用它的结果集插入到指定的参数中，主要的形式有appendTo(jquery),append(HTMLELments[]) 实例： 123456$("&lt;img src='lily.png'&gt;").appendTo($("img").last().parent()); //将图片插入到最后一个dcell中，这里参数是目标位置，开头调用的时想要插入的内容$("img:first").clone().appendTo($("img").last().parent()); //选择第一个图片插入到最后一个dcell中，这里必须用clone，否则就会将这张图片移到目标位置 $($("div.dcell").html()).appendTo($("img").last().parent()); //这里的.html()是获取html文本内容 prependTo .prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同。 对于 .prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 .prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。 after 在匹配元素集合中的每个元素后面插入参数所指定的内容，作为其兄弟节点。形式有after(content[content,]),after(function()),这里的content内容有HTML字符串，DOM 元素，文本节点，元素和文本节点的数组，或者jQuery对象，用来插入到集合中每个匹配元素的后面 实例： 123456789101112131415 var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;"); //创建一个dcell内容 $("div.dcell").after(orchildElems); //插入元素作为兄弟元素，在当前元素的后面 $("#row1 div.dcell").after(function (index, html) &#123; //index表示索引，html表示原来的html文本，指的是没有插入之前的html console.log(html); if (index == 0)return orchildElem; //返回的可以是jquery对象，html文本 else if (index == 1) return newElems; &#125;);&#125;); before 根据参数设定，在匹配元素的前面插入内容,形式和after一样，内容也差不多 insertBefore 和prependTo的用法差不多，只是参数是要插入的目标位置，作为兄弟元素插入 实例： 1orchildElems.clone().insertBefore("#row2 div.dcell"); insertAfter 和append用法差不多，只是参数是要插入的目标位置，这里的也是作为兄弟元素插入的 实例： 1orchildElems.insertAfter("#row1 div.dcell"); wrap 在集合中匹配的每个元素周围包裹一个HTML结构，将会作为父元素存在。形式为wrap(html),wrap(jquery),wrap(HtmlElements[]),wrap(function()) 实例： 1234567891011 div=$("&lt;div&gt;&lt;/div&gt;").css("border",'thick double red'); $("div.drow").wrap(div); //在drow外层添加了一个div将作为父元素，可以看到现在的源代码变成了&lt;div style...&gt;&lt;div class='drow'&gt;...&lt;/div&gt;&lt;/div&gt; $(".drow").wrap(function (index) &#123; //index是索引 //if($(this).has("img[src*=astor]").length&gt;0) if(index==0) return div; //只在第一个drow中添加父元素div else return $("&lt;div&gt;&lt;/div&gt;").css("border",'thick double blue');&#125;) unwrap 将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。形式为unwrap(),unwrap(selector) 实例： 1234$("div.dcell").css("border",'thick double red'); $("div.dcell").children("img").first().unwrap(); //这里将第一个img元素的父级元素删除，并且保留了其中的子元素 $("div.dcell").children("img").unwrap(":first"); //这里使用参数来筛选要删除父级元素的当前元素，这里选择第一个元素 wrapAll 在集合中所有匹配元素的外面包裹一个HTML结构,也就是为结果集中的所有元素都设置了一个相同的父级元素来包裹所有的元素，形式为wrapAll(html),wrapAll(jquery),wrapAll(htmlElements[]),wrapAll(function()) 实例： 123var div = $("&lt;div&gt;&lt;/div&gt;").css("border", 'thick double red');$("div.drow").wrapAll(div); //这里的div成为了他共有的父级元素，原来的父级元素变成了祖先元素了$("img").wrapAll(div); //这里的img没有共同的父元素，那么就会强制的将所有的元素拉在一起为他们设置一个父级元素 wrapInner 在匹配元素里的内容外包一层结构,也就是为匹配元素的后代元素添加一个父级元素，但是这个父级元素是匹配元素的子代元素，也就是原来的匹配元素变成了祖先元素，形式为wrapInner(html),wrapInner(jquery),wrapInner(htmlElements),wrapInner(function()) 实例： 12var div = $("&lt;div&gt;&lt;/div&gt;").css("border", 'thick double red');$(".dcell").wrapInner(div); //这里的dcell元素将会变成祖先元素，而div将会变成内部后代元素新的父级元素 replaceWith 用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合,形式为replace(html),replaceWith(jquery),replaceWith(function()) 实例： 12345678910111213 var newElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='lily.png'&gt;") .append("&lt;label for='lily'&gt;Lily&lt;/label&gt;").append("&lt;input name='lily' value='0' required&gt;").css("border", 'thick double blue');$(".dcell:first").replaceWith(newElems); //用newElems替换第一个dcell$("div.drow img").replaceWith(function () &#123; if (this.src.indexOf("rose") &gt; -1) return $("&lt;img src='lily.png'&gt;").css("border",'thick double red'); //返回的时替换的内容，可以是jquery或者html else if (this.src.indexOf("peony") &gt; -1) return newElems; else return $(this.clone()).css("border",'thick double blue');&#125;) replaceAll 用集合的匹配元素替换每个目标元素。.replaceAll()和.replaceWith()功能类似，但是目标和源相反 实例： 1$("&lt;img src='lily.png'&gt;").replaceAll("#row1 img"); //这里使用&lt;img src='lily.png'&gt;替换所有的img元素 remove 将匹配元素集合从DOM中删除,并且同时移除元素上的事件及 jQuery 数据 实例： 123$("div.dcell").remove(":has(img[src*=rose])"); //删除img$("div.dcell:first()").remove(); //不带参数 detach 从DOM中去掉所有匹配的元素,.detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 实例： 123$("div.dcell").detach();$("div.dcell").detach(":has(img[src*=rose])"); empty 从DOM中移除集合中匹配元素的所有子节点。 1$(&quot;div.dcell:first&quot;).empty(); //删除所有的子节点 参考文章 JQuery中文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之选择元素]]></title>
      <url>%2F2017%2F04%2F20%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JQuery 干货篇之选择元素实验的HTML+CSS的代码 html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src="jquery-3.2.1.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="main.css"/&gt; &lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Jacqui's Flower Shop&lt;/h1&gt;&lt;form method="post"&gt; &lt;div id="oblock"&gt; &lt;div class="dtable"&gt; &lt;div id="row1" class="drow"&gt; &lt;div class="dcell"&gt; &lt;img src="astor.png"/&gt;&lt;label for="astor"&gt;Astor:&lt;/label&gt; &lt;input name="astor" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="daffodil.png"/&gt;&lt;label for="daffodil"&gt;Daffodil:&lt;/label&gt; &lt;input name="daffodil" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="rose.png"/&gt;&lt;label for="rose"&gt;Rose:&lt;/label&gt; &lt;input name="rose" value="0" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="row2" class="drow"&gt; &lt;div class="dcell"&gt; &lt;img src="peony.png"/&gt;&lt;label for="peony"&gt;Peony:&lt;/label&gt; &lt;input name="peony" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="primula.png"/&gt;&lt;label for="primula"&gt;Primula:&lt;/label&gt; &lt;input name="primula" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="snowdrop.png"/&gt;&lt;label for="snowdrop"&gt;Snowdrop:&lt;/label&gt; &lt;input name="snowdrop" value="0" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="buttonDiv"&gt; &lt;button type="submit"&gt;Place Order&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061h1 &#123; min-width: 70px; border: thick double black; margin-left: auto; margin-right: auto; text-align: center; font-size: x-large; padding: .5em; color: darkgreen; background-image: url("border.png"); background-size: contain; margin-top: 0;&#125;.dtable &#123; display: table;&#125;.drow &#123; display: table-row;&#125;.dcell &#123; display: table-cell; padding: 10px;&#125;.dcell &gt; * &#123; vertical-align: middle&#125;input &#123; width: 2em; text-align: right; border: thin solid black; padding: 2px;&#125;label &#123; width: 5em; padding-left: .5em; display: inline-block;&#125;#buttonDiv &#123; text-align: center;&#125;#oblock &#123; display: block; margin-left: auto; margin-right: auto; min-width: 700px;&#125;.hover&#123; background: blue; color: white; height:300px; width:300px;&#125; 选择器 :animated :选择正在处理动画的元素 :first :选择第一个元素 :last :选择最后一个元素 :eq(n) :选择第n个元素(从0开始) :even :选择序号为偶数的元素 :odd :选择序号为奇数的元素 :gt(n) :选择序号大于n的元素 :lt(n) :选择序号小于n的元素 :text :选择所有的文本输入框 :contains(text) :选择包含指定文本的元素 file :选择所有文件上传输入框 :button :选择所有的按钮 :checkbox :选择所有的复选框 :hidden :选择隐藏的元素 实例 $(&quot;img:odd&quot;).css(&quot;border&quot;,&quot;thick double red&quot;);选择序号为奇数的img元素$(&quot;img:first&quot;).css(&quot;border&quot;,&quot;thick double red&quot;) 选择第一个img元素 JQuery对象的方法 context 选择元素时使用的上下文对象 $(&quot;img:odd&quot;).context.TagName; each(function()) 在每个选中的元素上运行给定的函数 123 $("img").each(function(index,elem)&#123; console.log(ele.TagName+" "+elem.id);//这里的index表示每一个元素的索引，elem表示每一个元素的htmlElement对象，并不是jquery对象&#125;) index(jquery) || index(selector) 返回给定jquery对象在住对象中的序号，或者返回给定选择器参数的索引 $(&quot;img&quot;).index(&quot;img[src=*astor]&quot;) length || size() 返回的时jquery对象个数 $(&quot;img:odd&quot;).length toArray() 返回一个有jquery对象中包含的htmlEelments数组 var content=$(&quot;img:odd&quot;).toArray() 这里content返回的htmlElements数组 把jquery当成数组12345var content=$("img:odd");for(var i=0;i&lt;content.length;i++)&#123; console.log(content[i].TagName+" "+content[i].src); //这里的content[i]就是htmlElement数组了，$(content[i])就变成了Jquery对象了&#125; add add函数允许我们添加更多的项，常用的有add(htmlElement[]),add(selector),add(jquery) 实例： 1234567$("img:odd").add("img:even").css("border",'thick double red');var jq=$("img[src*=astor]");$("img:even").add(jq).add("img:even").css("border",'thick double red');var label=document.getElementsByTagName("label");$("img:odd").add(label).css("border","thick double red"); slice() 用来获取特定的一组子元素 实例： 123$("img").slice(0,3).css("border","thick double red"); //获取0-2的元素 $("img").slice(3).css("border","thick double red"); //获取3-结束 filter filter可以将不满足指定条件的元素剔除，常用的方法有filter(jquery),filter(htmlElement),filter(function(index)),filter(selector) 实例 1234567891011121314 //这里填入的参数selector$("label").filter("[for*=p]").css("background-color",'blue').css("font-size",'20px').css("border","2px solid red"); $("img").filter(function (index) &#123; //index是每一个元素的索引，如果返回的是true就会选定，false就会剔除这个元素 if(index==4) &#123; return true; &#125; else return false; &#125;).css("border",'thick double red'); var elem=document.getElementsByTagName("label")[1]; //只选择第二个label $("label").filter(elem).css("font-size",'30px') //这里填入的参数是htmlElement对象 not not方法是filter方法的补充，主要是删除匹配条件的元素，而filter则是保留满足匹配条件的元素，常用的方法有not(selector),not(htmlElement),not(jquery),not(function(index)) 实例： 123456789$("label").not("[for*=p]").css("background-color",'red'); //选择for不带p的label元素 $("label").not(function (index) &#123; //哪个元素返回true就删除，false保留 if(index==0) return true; //这里就会删除第一个label元素，保留后面的元素 else return false; &#125;).css("background-color","yellow"); has 选择拥有指定后代的选择器 实例：1234$("div.dcell").has("img[src*=astor]").css("border","thick double red"); //选择子代拥有img属性src带有astor的div.dcell元素var s=$("[for*=astor]");$("div.dcell").has(s).css("border","thick double red"); //参数为jquery对象 map 以一个函数为参数，map方法能够帮助我们灵活的处理一个jquery对象，从而得到满足需要的一个jquery对象。针对源jquery对象中的每一个元素都调用一次这个函数，而函数返回的HtmlElement对象将会变成一个jquery对象，参数是function(index,elem),其中`index是序号，elem是jquery对象中的每一个HTMLElelments对象，这里必须要有返回值，不然没有意义 实例： 12345678910$("div.dcell").map(function(index,elem)&#123; return elem.getElementsByTagName("img")[0]; //这里的elem是$(div.dcell)中的每一个HtmlElement对象，返回的是img元素&#125;).css("border",'thick double red'); //可以很清楚的看到这里返回的htmlElement对象变成了Jquery对象，因为调用了函数css$("img").map(function(index,elem)&#123; if(index==1) return elem; //返回的是第二个img的HtmlElement对象，但是经过map的包装就会变成jquery对象&#125;).css("border",'thick double red'); //可以很清楚的看到这里返回的htmlElement对象变成了Jquery对象，因为调用了函数css is is方法确定jquery对象中的某个或者某些元素是否满足测试条件，其中的形式有is(selector),is(HtmlElement),is(jquery),is(function(index))如果结果集中至少有一个元素匹配指定的条件，那么就返回true,否则false 实例：1234567891011console.log($("img").is("[src*=astor]"));//这里是判断img中的src属性有没有astor字段的，如果存在返回true$("img").is(function(index)&#123;&#125;)var c=$("img").is(function (index) &#123; //函数中如果至少有一个返回true，那么就会返回true，index是索引 return this.getAttribute('src')=='rose.png'; //判断属性 &#125;); console.log(c); end 当我们调用方法链来修改结果集的时候，jquery维护者一个历史结果集的查找，我们可以利用end回退到历史的结果集中,end用来扔掉当前的结果集，返回到上一层结果集 实例： 1234$("img").filter("[src*=astor]").end().css("border",'thick double red'); //这里回退到$("img")这个结果集中$("div.dcell").find("img").filter(":odd").filter(":eq(0)").end().end().css("border",'thick double red'); //这里调用了两个end将结果集回退到$("div.dcell").find("img")中 addBack 得到当前结果集和上一个结果集的合集 实例 123456$("div.dcell").children("img").addBack().css("border",'thick double red');//这里得到的是$("div.dcell")和$("div.dcell").children("img")的合集，并且应用css$("img").slice(0,3).filter("[src*=astor]").addBack().css("border",'thick double red');//$("img").slice(0,3)和$("img").slice(0,3).filter("[src*=astor]")的合集//这里的选择器参数过滤的是原结果集，相当于$("img").slice(0,3).filter("[src*=daff]")，$("img").slice(0,3).filter("[src*=astor]").addBack("[src*=daff]").css("border",'thick double red'); children children是用来访问子元素的，形式有childern(),children(selector),其中第一个是用来得到结果集中所有的子元素，第二个是用来过滤得到的子元素，保留满足selector的子元素 实例： 123$("div.dcell").children().css("border",'thick double red');//得到所有div.dcell的子元素，包括其中的img和input元素$("div.dcell").children("img").css("border",'thick double red');//得到所有子元素中的img元素 find find是用来得到结果集中的所有的后代元素，这里是后代元素，并不是只有子元素，还包括孙子。。。，形式有find(),find(selector),find(htmlElement),find(jquery),find(htmlElment[])，这里会自动去掉含有重复的元素，因此可以用来过滤元素 实例 1234$("div.dcell").find("img"); //找到div.dcell的后代元素imgvar content=document.getElementsByTagName("input");$("div.dcell").find(content).filter(":first").css("font-size",'1.5em');//找到div.dcell后代元素中的input元素 parent 选取结果集中的父元素，这里表示一层关系就是父元素，并不是祖先元素，形式有parent(),parent(selector) 实例：123$("img").parent(); //选取img的父元素$("img").parent(":first"); //选取img父元素中的第一个元素 parents 选取祖先元素，包括父元素，形式有parents(),parents(selector) 实例：123456$("img").parents().each(function(index,elem)&#123; //选取所有的祖先元素 console.log(elem.TagName+" "+elem.id);&#125;)$("img").parents("div.dcell").css("border",'thick double red'); //选择所有的div.dcell元素 parentsUntil 选择祖先元素，知道找到这个当前祖先元素匹配参数选择器为止,parentsUntil(selector),parentsUntil(selector,selector)，其中带有两个参数选择器中的第二个参数是用来筛选所得到的结果集，第一个是用来定位直到这个元素为止 实例： 123$("img").parentsUntil("div.drow");//找img的祖先元素，直到div.drow为止，不包括div.drow $("img").parentsUntil("div.drow",":first").css("border",'thick double red'); //这里选择了结果集中的第一个元素应用了样式 closest 得到结果集中元素的祖先元素中匹配selector选择器最接近的那个祖先元素，形式为closest(selector),closest(selctor,context),closest(htmlElemtent),closest(jquery) 实例： 12345678910$("img").closest("div.drow").each(function (index,elem) &#123; //选择满足div.drow的祖先元素，这里的最接近就是辈分最接近，这里的两个class=drow的div都是最接近的，因为这俩个是同级的关系 console.log(elem.tagName+" "+elem.id); &#125;); var jq=$("#row1,#row2,form"); //传入jquery对象 $("img").filter("[src*=astor]").closest(jq).each(function (index,elem) &#123; //这里选取的是最接近第一张图的祖先元素，当然是&lt;div id="row1"&gt; console.log(elem.tagName+" "+elem.id); &#125;) offestParent 得到距离最近的祖先定位元素，使用fixed,absolute,relative定位的元素，形式为offestParent() siblings 得到所有的兄弟元素，可选的selector用来过滤结果，形式为siblings(),siblings(selector) 实例： 123$("img").siblings().css("font-size",'1.4em');// 得到img的所有兄弟元素，这里是input$("img").siblings(":last"); //得到img所有兄弟元素中的最后一个元素 prev 得到上一个兄弟元素，形式为prev(),prev(selector)，其中的selector是用来过滤结果的 实例： 1$("input").prev().css("border",'thick double red'); //这里得到input的上一个元素Label元素 prevAll 得到当前元素的所有的上面的兄弟元素，形式为prevALl(),prevAll(selector) 实例： 123$("input").prevAll().css("border",'thick double red'); //得到input上面的所有的兄弟元素$("input").prev("img").css("border",'thick double red'); //得到input上面的所有的img元素 prevUntil 这个和parentsUntil一样，直到匹配selector就结束了，不包括 实例： 1$("input").prevUntil("i").css("border",'thick double red'); next 选择当前元素下面的一个兄弟元素，和prev一样 nextAll 选择当前元素下面的所有兄弟元素，和prevAll一样 nextUntil 和prevUntil一样 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇三]]></title>
      <url>%2F2017%2F04%2F16%2FSQL%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%89%2F</url>
      <content type="text"><![CDATA[SQL干货篇三创建视图 create view &lt;视图名&gt;[(列名),(列名)...] as &lt;子查询&gt; [with check option] 子查询可以是select语句或者包含order by子句，具体情况而定，视图名是一定要有的，列名可以省略，如果省略的话则是由子查询中的目标列的相关字段组成，当然也可以自己指定，with check option表示如果视图或者参照表执行insert,update,delete时，那么视图或者参照表会随着变化，也就是两个绑定在一起的意思，当然也可以选择不用，那么视图的增删改就和参照表没有关系了实例建立在一个表上12create view IS_student as select Sno,Sname,Sage where Sdept='IS'with check option ; /*将所有的IS系的学生学号建立一个视图IS_student,其中的列名是Sno,Sname,Sage*/ 建立在多个表上123create view IS_Grade(Sno,Sname,Grade) as select student.Sno,Sname,Grade from student,SCwhere Sdept='IS' and student.Sno=SC.Sno; /*建立在两个表上的视图，可以看出这里已经指出指定的列名，但是这个列名并不是固定的，可以根据具体的含义来指定*/ 定义一个带有表达式的视图123create view BT_S(Sno,Sname,Sbirth) as select Sno,Sname,2014-Sage from student /*这里的2014-Sage是用来计算出生日期的*/with check option; 聚集函数的视图12create view BT(Sno,Gavg) as select Sno,AVG(Grade) from SC Group by Sno; /*这里的AVG(Grade)是用来计算平均成绩的，Group by是用来根据学号分组，这里就是求同一个人的多门学科的平均成绩*/ 删除视图 Drop view &lt;视图名&gt;&lt;CASCADE],这里的CASCADE表示如果还导出了其他的视图，那么加上CASCADE就会全部删除 实例 Drop view IS_Sdept; 删除视图 Drop view IS_Sdept CASCADE; 删除视图和其导出视图 查询视图 查询视图和查询表是一样的，请参照我前两章讲的SQL语法 更新视图 视图的更新包括insert,delete,update,这个和基本表的操作是一样的 注意： 并不是所有的视图都可以更新的,比如上面根据学生多科平均成绩建立的视图，这里如果将视图中的平均成绩更新了，那么参照表的数据就不能对应的更新了，这就会不允许更新，当然这是在添加了with check option语句的情况下 如果添加了with check option语句,那么对视图的更新就会对应转换成对基本表的更新 各个系统对视图的更新还有进一步的规定，比如DB2规定： 如果视图是由两个以上的基本表导出，那么就不可以更新 如果视图来自字段或者表达式，那么就不允许对此视图执行insert,update,但是可以执行delete 如果定义中有order by子句，那么不可以更新视图 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java连接mysql初探篇]]></title>
      <url>%2F2017%2F04%2F16%2Fjava%E8%BF%9E%E6%8E%A5mysql%E5%88%9D%E6%8E%A2%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java连接mysql基本连接 加载驱动: Class.forName(com.mysql.jdbc.Driver) 建立连接:Connection conn=DriverManager.getConnection(url,user,password) 其中url=&quot;jdbc:mysql://localhost:3306/java_demo&quot;,这里的java_demo是自己创建的数据库的名字,user是mysql数据库的管理员，password是密码下面直接连接数据库，返回的是接口Connection对象 1234567891011121314151617181920212223242526import java.sql.*;public static Connection getConnection()&#123; Connection conn; String driver="com.mysql.jdbc.Driver"; //驱动名称 String url="jdbc:mysql://localhost:3306/java_demo"; //url String user="root"; String password="root"; //管理员和密码都是root try&#123; Class.forName(driver); //加载驱动，但是会有ClassNotFoundException异常，因此要避免异常 try&#123; conn = Dri verManager.getConnection(url, user, password); //获得数据库连接 return conn; //返回conn &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; //如果出现异常就会返回null &#125; 查询数据 **首先根据所得的Connection对象创建Statement对象：Statement statement = connection.createStatement(); 写查询语句：String sql=&quot;select * from student;&quot;这里是查询所有student中的数据，详细内容请看我的SQL干货篇二 创建ResultSet对象存储查询结果:ResultSet res=statement.executeQuery(sql),详细的内容请看官方文档ResultSet详细用法 代码1234567891011String sql="select * from student";if(!conn.isClosed())&#123; Statement statement=conn.createStatement(); //这里的conn是上面连接数据库的返回的Connection对象 ResultSet res=statement.executeQuery(sql); //执行查询，注意这里只能是executeQuery，Statement还有一些执行mysql函数，但是都不适合查询，后面会详细说 while(res.next()) //如果res结果中还有元素，那么返回true，否则返回的是false,用来判断是否res中还有结果 &#123; int id=res.getInt("id"); //得到id,这里的id是student表中的属性名 对应的时int BigInt smallint..... String name=res.getString("name"); //得到姓名，对应的是mysql中的Char varChar类型 &#125;&#125; 当然上面只是对于基本的查询数据，在一些项目中根本用不到，因为不太灵活，上面的方法只适合全局查询，并不适合在项目中根据条件查询，下面介绍预编译sql语句的接口PrepareStatement 首先编写sql语句:sql=&quot;select * from student where id=?;&quot;;,这里的?表示一个占位，将条件在后面给出，但是这里一定要用? 创建对象：PrepareStatement pre=conn.preparestatement(sql);这里传入参数sql 设置sql中的条件语句，填补占位?的值:pre.setInt(1,1);这里的SetInt设置id值的为1，因为这的id是int类型的，第一个参数是表示prepareindex，就是表示第一个占位?,当然第二个就是2,其中还有SetString(prepareindex String var),用来给定表中的char后者varchar类型的值 代码：1234567891011121314if(!connection.isClosed()) &#123; String sql="select * from course where id=?,name=?"; PreparedStatement preparedStatement=connection.prepareStatement(sql); preparedStatement.setInt(1,1); //给定条件中的值 prepareStatement.setString(2,"jack"); //为第二个？赋值 ResultSet res=preparedStatement.executeQuery(); //执行查询，返回的仍然是ResultSet对象 while(res.next()) &#123; int id=res.getInt("id"); String name=res.getString("name"); System.out.println(id+"--"+name); &#125; &#125; 插入数据 插入数据和上面的两种方法基本是一样的，不同的是mysql语句不同，还有的就是执行语句改成了executeUpdate(sql)，下面的代码值给出了预编译对象的方法，另外一种的方法使用范围并不是很大，只要把上面的查询改为executeUpdate即可 代码：1234567891011121314151617181920212223242526272829303132public static int save(MemoBean memo) &#123; String sql = "insert into student (username, title, content, momotype, memotime) values (?, ?, ?, ?, ?);"; Connection conn = getConnection(); PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); ps.setString(1, memo.getUsername()); //设值value中的值 ps.setString(2, memo.getTitle()); ps.setString(3, memo.getContent()); ps.setString(4, memo.getMemotype()); ps.setString(5, memo.getMemotime()); return ps.executeUpdate(); //这里使用的是excuteUpdate &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) &#123; try &#123; ps.close(); //关闭预编译对象 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); //关闭Connection对象 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1; //没有插入成功返回-1 &#125; 更新数据 这里是同样的思路，和插入的基本是一样，只需要改变sql语句即可 代码：1234567891011121314151617181920212223242526272829303132333435363738public static int update(MemoBean memo) &#123; String sql = "update student set username=?,title=?,content=?,momotype=?,memotime=? where id=?;";//查询语句 Connection connection = getConnection(); PreparedStatement ps = null; try &#123; ps = connection.prepareStatement(sql); ps.setString(1, memo.getUsername()); //设置条件语句中的值 ps.setString(2, memo.getTitle()); ps.setString(3, memo.getContent()); ps.setString(4, memo.getMemotype()); ps.setString(5, memo.getMemotime()); ps.setInt(6,memo.getId()); return ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ps!=null) &#123; try &#123; ps.close(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null) &#123; try &#123; connection.close(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1; &#125; 最后说 上面的代码是从自己项目中截取的一部分代码，这个是比较适用于面向对象的，也是最常用的对于目前来看 上面只是给出了查询，插入，更新，因为这是最常用到的方法，其中还有创建表，删除表，当然还有一些他的，这里的创建表直接用execute(sql)即可执行，删除表也是用execute(sql)即可执行，当然如果要按照指定的条件删除，那么可以使用预编译对象执行 其中executeUpdate(sql)适用于create,insert,update,delete,但是executeQuery(sql)适用于select,具体见官方文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux干货篇一]]></title>
      <url>%2F2017%2F04%2F13%2FLinux%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Linux干货篇一虚拟机的安装(VMware) 选择文件-&gt;新建虚拟机 选择自定义 设置安装来源，选择稍后安装 选择安装的操作系统，选择Linux,然后选择自己安装的对应版本即可 设置虚拟机的安装路径，自己选择 指定磁盘容量，选择默认20G,然后选择将虚拟磁盘存储为单个文件 设置cpu数量，内存大小，默认即可 设置Linux安装镜像文件路径 点击开启虚拟机即可根据对应的设置安装 目录文件 /boot:存放系统引导时所需要的文件，包括Linux内核以及引导程序(BootLoader) /bin:存放可执行程序 /etc:存放系统配置文件 /home:普通用户的主目录所在位置 /lib:存放基本的共享文件和内核模块 /mnt(mount):用户为需要挂载的文件系统提供挂载点 /proc(process):存放与内核进程有关的信息 /root:根用户的主目录 /tmp(temporary):存放临时性文件 /usr(user):存放可共享的只读文件 /var(variable):存放各类的数据文件 ls重要选项 -a(all) 列出目录中的所有项，包括”.”开头的隐藏文件 -l(list) 以列表的方式显示文件 -R(recursive) 用于递归列出子目录中的内容，如果在选择的目录下还有子文件夹，那么可以列出子文件夹中的文件 -d仅仅列出目录本身的信息实例 ls -al /etc 以列表的方式列出ect目录下的所有文件 pwd 显示当前路径cd(切换目录) cd .. 跳闸到当前目录的上一级 cd ~ 跳转到当前用户的主目录 例子 cd /tmp/testdir 跳转到tmp文件下的testdir目录 stat 获取关于某文件的基本信息，包括创建的信息，大小，时间。。。。 实例 stat test 查看test文件的基本信息 touch 创建或者更新一个文件的访问和修改的时间，如果一个文件存在，那么更新这个文件的创建时间，但是文件的内容不会改变，如果文件不存在，那么就会在当前目录下创建一个文件 实例 touch /tmp/testdir/test 在指定路径下创建一个test文件，如果存在那么会更新创建的时间，可以使用stat命令查看创建时间 mkdir(创建目录) mkdir /tmp/testdir/test_file 在/tmp/testdir目录下创建一个test_file文件夹 mv 移动或者重命名文件或目录 重要选项 b(backup):若存在同名文件，覆盖前先备份原来的文件 f(force):强制覆盖同名的文件 实例12345mkdir /tmp/testdir //创建一个目录testdirtouch test1 test2 //创建两个文件test1 test2mv -b test1 test2 //移动test1为test2,这里会先备份原来的test2为test2~mv -b test1 /tmp/testdir1/test //移动文件到指定目录下 cp(copy) 复制文件和目录 选项 -b: 若存在同名文件，覆盖前先备份 -f :强制覆盖同名文件 -r : 以递归的方式复制文件，就是复制文件夹，如果不使用这个，那么文件夹就无法复制 实例 cp /tmp/testdir tmp/testdir1 复制文件夹，这里表示不能复制，因此要加上-r选项才能复制文件夹 -&gt; cp -r /tmp/testdir /tmp/testdir1 可以复制，复制到/tmp文件夹下命名为testdir1 cp -b /tmp/testdir/test1 /tmp/testdir1/test 将文件test1复制到testdir1文件夹下命名为test rm 删除命令 选项 -f 强制删除 -r 删除文件夹（递归删除） 实例 rm -rf /tmp/testdir 强制删除testdir目录 rmdir 删除目录，但是要求目录必须是空的，这里实用性不大，一般用rm -r cat 查看文件内容 重要选项 -n 显示行数 实例 cat -n /tmp/testdir/test 查看文件test的内容，显示行数 more 分屏显示文件内容，首先显示一屏后如果还有内容，按回车键在显示下一行，按Space显示下一屏的内容 实例 more /tmp/testdir/test tail 显示文本文件结尾的部分，默认显示最后10行 重要选项 -n 指定显示的行数 head 显示开头的内容，与tail类似 wc 一次显示文本文件的行数，单词数，字节数 重要选项 -c 显示文件字节数 -l(line) 显示文件行数 -w(word) 显示文件单词数 实例 wc -cl /tmp/testdir/test 查看文件的字数和文件的行数 date查看或者修改系统命令 实例 date 查看系统时间 date 09012017 修改系统时间为2017-09-01 who列出当前系统的登录用户 重要选项 -r 显示系统当前的运行级 -q 显示当前所有登录的用户名称和在线人数 shutdown关闭重启系统 重要选项 -r(reboot) 重启系统 -h(halt) 关闭系统 -P(poweroff) 关闭系统同时关闭电源 注意上面选项均可给出数字参数指定多少分钟之后执行操作 实例 shutdown -h 10 设置10分钟后关闭系统 clear清楚当前终端的屏幕内容 man显示命令的使用手册，按上下键移动光标，Q键退出 实例 man cat 快速查询cat命令的手册 histroy查看shell命令的历史记录 实例 histroy 5 显示最近的5条记录 vim调用vim编辑器，按i键插入，w键保存，q键退出，wq保存后退出 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇二]]></title>
      <url>%2F2017%2F04%2F09%2FSQL%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[SQL干货篇之查询数据单表查询 只在一个表中查询数据1SELECT * FROM student where Sno='13143'; //根据学号查询数据 多表查询 同时查询多个表12SELECT student.Sno,student.Sname,GradeFROM student,SC where Grade&gt;=90; 说明：这是在学生表student和成绩表SC中查询成绩大于90的学生姓名和学号,因为这里Sno,Sname在两个表中都存在，因此要指定查询哪一个表中的数据，而Grade只在SC表中出现，因此不用指明哪张表 模糊查找 说明：模糊查找用like和not like进行查找 SELECT * FROM student where Sname like &#39;刘%&#39;;查询所有姓刘的学生 SELECT * FROM student where Sname like &#39;%加%&#39;查询名字中含有加字的学生信息，不固定加字的位置，在任意位置都能查到，这里一般搜索引擎都用是用这种模糊查找的方法来匹配搜索项 SELECT * FROM student where Sname like &#39;欧阳_&#39;;查找以姓欧阳并且名字为三个字的学生信息 SELECT * FROM student WHERE Sname like &#39;_阳&#39;;查找所有姓名为两个字并且第二个字为阳的学生信息 SELECT * FROM student where Sname like &#39;_阳%&#39;;查询所有姓名中第二个字为阳的学生信息 SELECT * FROM Course where Cname like &#39;\_IS&#39; ESCAPE &#39;\&#39;;查询课程名字为_is的课程信息，这里如果要查询的字符串本省就含有通配符”%“或者”_“，这时就要使用ESCAPE&lt;转码字符&gt;来对字符进行转义了，这里的转码字符可以是任意的，但是我们通常都是用\,上面的查询语句中的\就是转码字符 空值查询 判断数据是否为空用is not null和is nullSELECT * FROM student where Sname is null;查询姓名为空的学生信息 多重条件的查询 多重条件的查询用AND和OR,其区别不用多说了SELECT Sname FROM student where Sdept=&#39;IS&#39; and Sage&gt;20;查找院系是IS并且年龄超过20岁的学生姓名 ORDER BY子句(排序) 用户可以使用ORDER BY子句对数据进行升序(ASC)或者降序(DESC)排列 SELECT * FROM student where Sage&gt;20 ORDER BY Sno DESC;查询年龄超过20岁的学生信息，并且按照降序排列输出 SELECT * FROM student ORDER BY Sdept,Sage DESC;查询全体学生情况，查询结果按照所在系的系号升序排列，同一系的按照年龄降序排列 聚集函数 COUNT(*) 统计元组个数 COUNT(DISTINCT|ALL &lt;列名&gt;) 计算一列中值的个数，其中DISTINCT表示去除重复的元素，ALL则保留所有的元素 SUM(DISTINCT|ALL &lt;列名&gt;) 计算一列值的总和 AVG(DISTINCT|ALL&lt;列名&gt;) 计算一列中的平均值 MAX(DISTINCT|ALL&lt;列名&gt; ) 求一列中的最大值 MIN(DISTINCT|ALL&lt;列名&gt; ) 求一列中的最小值 实例： select count(*) from student; 查询学生总数 select count(DISTINCT Sdept); 查询总共有多少系 select AVG(Grade) from SC; 查询学生的平均分 select SUM(Grade) from SC; 查询学生的总分 select MAX(Grade) from SC where Cno=&#39;1&#39;; 查询课程1的最高分 select MIN(Grade) from SC where Cno=&#39;1&#39;; 查询课程1的最低分 注意：where子句中不能用聚集函数，只有在select子句和Group by子句中才能使用聚集函数 GROUP BY子句 GROUP BY子句将查询结果按某一列或者多列的值分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的对象。如果未对查询结果进行分组，那么聚集函数将会作用于整个查询结果，分组后聚集函数将会作用于每一组，即每一组都有一个函数值 实例： select Cno,Count(Sno) from SC Group by Cno; 求各个课程号以及相应的选课人数 select Cno as &#39;课程号&#39;,count(Sno) as &#39;选课人数&#39; from sc group by Cno;求各个课程号以及相应的选课人数 select Cno,count(Sno),AVG(Grade) from sc group by Cno Having AVG(Grade)&gt;80; 查询课程平均分大于80分的课程号和所选学生人数,这里是先分组后然后对这些组进行筛选就用Having子句进行条件筛选，不能使用where子句进行筛选,当然这里的sleect子句中的AVG(Grade)可以去掉,可以写成select Cno,count(Sno) from sc group by Cno Having AVG(Grade)&gt;80; select Sno from sc Group by Sno having count(*)&gt;2; 查询选修了两门以上课程的学生学号 select Sno,AVG(Grade) from sc Group by Sno; 查询每一个学生选修课程的平均成绩,这里先按照学号进行分组，然后对每一个分组进行求平均成绩 注意：这里的如果使用了聚集函数，那么select子句中出现的选项一定要在聚集函数或者Group by子句中出现，否则就会出现错误，如：select Sno,count(Cno) from sc;这条语句就是错误的，因为Sno没有出现在聚集函数或者Group by子句中，如果改成select Sno,count(Cno) from SC Group by Sno;就正确了,因为Sno出现在了Group by子句中了 连接查询 如果一个查询涉及两个以上的表则称之为连接查询，连接查询包括等值连接查询，自然连接查询，自身连接查询，非等值连接查询，外连接查询，复合条件查询 等值和非等值连接查询当连接运算符为=时为等值连接查询，否则为非等值连接查询 实例： select student.*,SC.* from student,SC where student.Sno=SC.Sno;查询每个学生及其选修课程的情况 自然连接查询在等值连接的基础上去掉相等的属性组就是自然连接查询 实例：select student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from student,SC where student.Sno=SC.Sno; 嵌套查询 在SQL语言中一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另外一个查询块的WHERE子句或HAVING短语的条件查询称之为嵌套查询实例：12SELECT SNAME FROM STUDENT WHERE SNO IN /*外层查询*/(SELECT SNO FROM SC WHERE CNO='2'); /*内层查询或者子查询*/ 注意: 这里的查询条件Sno只能有一个，并且外层查询的where子句中出现的Sno属性要和内层查询select语句中的Sno属性要对应。 子查询中不能使用ORDER BY子句，ORDER BY子句只能对最终的查询结果排序 带有IN谓词的嵌套查询 实例： 12345678910SELECT Sno,Sname,Sdept from student where Sdept IN(SELECT Sdept From student Where Sname='刘晨');``` **查询与刘晨在同一个系的学生信息,当然本例中也可以用自身连接查询来完成，如下：**```sqlselect first.Sno,first.Sname,first.Sdept from student first,student secondwhere first.Sdept=second.Sdept and second.Sname='刘晨'; 带有比较运算符的子查询12select Sno,Cno from sc x where Grade &gt;(select AVG(Grade) from sc y where x.Sno=y.Sno); 查询了所有学生成绩超过选修课程平均成绩的课程号 带有ANY或者ALL的谓词子查询 ANY表示查询条件只要满足其中一个即可，而ALL表示查询条件要满足所有的才行实例： SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&lt;ANY(SELECT SAGE FROM STUDENT WHERE SDEPT=&#39;CS&#39;) AND SDEPT!=&#39;CS&#39;;查询非计算机系的比计算机系任意一个学生年龄小的学生姓名和年龄,这里只要满足比一个学生的年龄小即可 SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&lt;ALL(SELECT SAGE FROM STUDENT WHERE SDEPT=&#39;CS&#39;) AND SDEPT!=&#39;CS&#39;;查询非计算机系的比计算机系的所有学生年龄小的学生信息，这里要满足比所有的学生信息都要小，就是比计算机系年龄最小的都要小 带有EXISTS谓词的子查询 EXISTS表示存在的意思，带有EXISTS的子查询步返回任何的数据，只产生逻辑真或者假 SELECT Sname From student where EXISTS (SELECT Sname from SC where Sno=student.Sno and Cno=&#39;2&#39;);查询选择课程2的学生姓名，这里只判断是否存在这样的学生，如果子查询中没有找到课程2这项，那么查到的就是空,子查询只判断是否为true or false,当然还有NOT EXISTS 集合查询 集合操作包括并操作UNION、交操作INTERSECT、差操作EXCEPT 实例： select * from student where Sdept= &#39;CS&#39; UNION select * from student where Sage&gt;19;查找计算机系的学生以及年龄不大于19岁的学生信息，这里UNION会自动去掉重复的元组，如果想要保留全部的数据需要用UNION ALL select Sno from SC where Cno=&#39;1&#39; UNION select Sno from SC where Cno=&#39;2&#39;;查询选修课程1或者选修课程2的学生学号，这里并集就是去掉重复的元组，使用UNION ALL 可以保留 select Sno from SC where Cno=&#39;1&#39; Intersect select Sno from SC where Cno=&#39;2&#39;;查询同时选修课程1和课程2的学生学号 基于派生表的查询123select Sno,Cno from SC,(select Sno,AVG(Grade) from SC Group by Sno) AS AVG_SC(avg_Sno,avg_grade)where SC.Sno=AVG_SC.avg_Sno and SC.Grade&gt;=AVG_SC.avg_grade; 这里的From子句中将会派生出一个AVG_SC表,该表由avg_Sno、avg_grade组成，主查询将SC表和AVG_SC表进行连接，选出修课成绩大于其平均成绩的课程号 注意：如果子查询中没有聚集函数，那么派生表不用指定属性列，子查询后面的列名为其属性，如下： select Sname from student,(select Sno From SC where Cno=&#39;1&#39;) AS SCI where student.Sno=SCI.Sno;这里的SCI默认的列属性名是Sno，AS关键词可以省略，但是必须要为派生表指定一个别名。 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java干货篇之文字特效]]></title>
      <url>%2F2017%2F04%2F09%2Fjava%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%96%87%E5%AD%97%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[java干货篇文字特效立体效果的文字主要使用了Graphics类中的setFont和setColor的方法，绘制多层字然后加上平移一个坐标即可实现多重叠加的效果,让人看起来就像是立体一样,详情请见源码 阴影效果的文字和面一样，只是平移的方式有些不同，详情请见源码 倾斜效果的文字主要使用的时Graphics2D类的shear方法，使绘图上下文倾斜，详情见源码public abstract void shear(double shx,double shy)其中shx表示在正x轴方向移动坐标的乘数，可以作为其y坐标的函数 渐变效果的文字主要使用了Graphics2D中的setPaint的方法,详情请见源码public abstract void setPaint(Paint paint)paint封装了渐变颜色的Paint对象其中Paint对象的创建是由GradientPaint初始化的,其中的构造函数如下：GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2) 会变色的文字这个主要使用了多线程的方式实现的，用多线程改变Color方法中的RGB的值,用Random在指定范围内任意取值然后组成了不同的颜色，详情请见源码 水印文字特效(源码)水印文字主要通过改变了文字的透明度实现的，将文字绘制在图片上，然后改变图片的透明度，主要使用了Graphaics2D中的setComposite方法，定义如下：public abstract void setComposite(Composite comp)，其中Comp是AlphaComposite对象，可以使用以下两种方式创建 AlphaComposite alpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.3f)获得一个SRC_OVER规则的对象 AlphaComposite alpha=AlphaComposite.SC_OVER.driver(0.3f)同上 动态绘制文本(源码)主要使用BufferedReader缓冲流从指定文件中读取一个字符，然后使用线程一个一个的绘制在画板上，中间sleep了400ms，这样就能展示出动态的效果，还使用了System类的getProperty方法获得项目的路径,以下提供了两种方法读取文件，更多的读取方法请看我的博客文章 BufferedReader read=new BufferedReader(new FileReader(pathname)) BufferedReader read=new BufferedReader(new InputStreamReader(in)) 由于都是比较简单的代码，这里不再贴出来le，有想要看的朋友，请点击上面的源码 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing干货系列之JTextField]]></title>
      <url>%2F2017%2F04%2F08%2FSwing%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJTextField%2F</url>
      <content type="text"><![CDATA[Swing系列之JTextField(单行文本框)介绍 JTextField是一个轻量级组件，它允许编辑单行文本。 JTextField 具有建立字符串的方法，此字符串用作针对被激发的操作事件的命令字符串。java.awt.TextField 把字段文本用作针对 ActionEvent 的命令字符串。如果通过 setActionCommand 方法设置的命令字符串不为 null，则 JTextField 将使用该字符串来保持与 java.awt.TextField 的兼容性，否则将使用字段文本来保持兼容性。 setEchoChar 和 getEchoChar 方法不是直接提供的，以避免可插入的外观的新实现意外公开密码字符。为了提供类似密码的服务，单独的类 JPasswordField 扩展了 JTextField，从而通过可插入外观独立地提供此服务。 JTextField 的水平对齐方式可以设置为左对齐、前端对齐、居中对齐、右对齐或尾部对齐。右对齐/尾部对齐在所需的字段文本尺寸小于为它分配的尺寸时使用。这是由 setHorizontalAlignment 和 getHorizontalAlignment 方法确定的。默认情况下为前端对齐。 文本字段如何使用 VK_ENTER 事件取决于文本字段是否具有任何操作侦听器。如果具有操作侦听器，则 VK_ENTER 导致侦听器获取一个 ActionEvent，并使用 VK_ENTER 事件。这与 AWT 文本字段处理 VK_ENTER 事件的方式是兼容的。如果文本字段没有操作侦听器，则从 1.3 版本开始不使用 VK_ENTER 事件。而是处理祖先组件的绑定，这将启用 JFC/Swing 的默认按钮特性。 Swing 不是线程安全的 构造函数 JTextField() 构造一个新的 TextField JTextField(Document doc, String text, int columns) 构造一个新的 JTextField，它使用给定文本存储模型和给定的列数。 JTextField(int columns) 构造一个具有指定列数的新的空 TextField。 JTextField(String text)构造一个用指定文本初始化的新 TextField。 JTextField(String text, int columns) 构造一个用指定文本和列初始化的新 TextField。 常用的函数 get/setHorizontalAlignment(int alignment) 设置/得到文本的水平对齐方式。其中水平的对齐方式有：JTextField.LEFT JTextField.CENTER JTextField.RIGHT JTextField.LEADING (the default) JTextField.TRAILING setFont(Font font) 设置字体 setScrollOffset(int scrollOffset) 获取滚动偏移量（以像素为单位）。 setDocument(Document doc) 将编辑器与一个文本文档关联，这里的意思就是将此文本框与一个文本文档关联，这将会保持内容一致，如果一个改变了，另外一个也会改变。 setInputVerifier(verifier) 设置验证方式，如果此文本不能通过验证那么就不能将焦点聚焦到下一个组件上，就会一直聚焦到这个文本框上 setDragEnabled(boolean x) 设置在文本框中是否能够拖放文本,为true则是能够，这里的意思就是能够将文本选中后能不能将文本拖走 addActionListener(ActionListener action) 添加监听机制，输入文本按回车即可触发，和按钮的监听机制相同 write(InfileWriter writer) 将文本框中的内容输入到文件中 addKeyListener(KeyListener event) 添加键盘监听，在文本框中输入内容时会触发键盘，其中有按下，释放，键入的动作，详情见官方文档 addCaretListener(CareListener event) 添加一个侦听文本组件插入符的位置更改的侦听器，只要鼠标指针的位置改变就会触发 一个简单的实例1234567891011121314151617181920212223242526272829303132333435363738394041import javax.swing.*;import java.awt.*;class text extends JFrame &#123; private JTextField textField1; private JTextField textField2; public static void main(String args[]) &#123; text my = new text(); my.setVisible(true); &#125; public text() &#123; //this.setBounds(100,100,300,200); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new GridLayout(2, 1)); textField1 = new JTextField(10); textField2 = new JTextField(); panel.add(textField1); panel.add(textField2); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); InputVerifier verifier = new InputVerifier() &#123; //添加验证方式 @Override public boolean verify(JComponent input) &#123; //重载函数 boolean value; textField1 = (JTextField) input; //将input组件强制转化为JTextField类型的单行文本框 return textField1.getText().equals("pass"); //判断是否输入的时pass,如果不是就会验证错误 &#125; &#125;; textField1.setInputVerifier(verifier); //设置验证方式 textField1.setHorizontalAlignment(JTextField.CENTER); //设置水平对齐方式 Font font = new Font("楷体", Font.BOLD + Font.ITALIC, 20); textField1.setFont(font); //设置字体 textField1.setDragEnabled(true); //设置在单行文本框中能够拖放文本，如果为false则不能够拖放文本 &#125;&#125; 关联文本文档123456789101112131415161718192021222324252627282930313233343536import java.awt.Container;import java.awt.GridLayout;/*from w ww.jav a 2s . co m*/import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;import javax.swing.text.Document;public class Main extends JFrame &#123; JLabel nameLabel = new JLabel("Name:"); JLabel mirroredNameLabel = new JLabel("Mirrored:"); JTextField name = new JTextField(20); JTextField mirroredName = new JTextField(20); public Main() &#123; this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setLayout(new GridLayout(2, 0)); Container contentPane = this.getContentPane(); contentPane.add(nameLabel); contentPane.add(name); contentPane.add(mirroredNameLabel); contentPane.add(mirroredName); Document nameModel = name.getDocument(); //得到文本框的文本文档，将之与第二个文本框关联 mirroredName.setDocument(nameModel); //两个文本框中的内容相互关联，这样只需要在一个里面输入文本，同时也会在另外一个文本框中显示 pack(); setVisible(true); &#125; public static void main(String[] args) &#123; Main frame = new Main(); &#125;&#125; 说明：这里是将两个文本框相关联，这样就能达到一个文本框输入的同时，另外一个也会同时更新内容 Action Listener(动作监听机制)输入文本后按回车即可触发123456789101112131415161718192021222324252627import java.awt.event.ActionEvent;//from w w w. ja va2s .c o mimport javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String[] a) &#123; JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField jTextField1 = new JTextField(); jTextField1.setText("jTextField1"); //添加监听机制 jTextField1.addActionListener(new java.awt.event.ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("action"); &#125; &#125;); frame.add(jTextField1); frame.setSize(300, 200); frame.setVisible(true); &#125;&#125; 验证文本内容使用InputVerifier)验证 12345678910111213141516171819202122232425262728293031import java.awt.BorderLayout;import javax.swing.InputVerifier;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Verifier Sample"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField textField1 = new JTextField(); JTextField textField2 = new JTextField(); InputVerifier verifier = new InputVerifier() &#123; //创建一个验证 public boolean verify(JComponent comp) &#123; boolean returnValue; JTextField textField = (JTextField) comp; //强制转换，将控件类型的comp转换成JTextFiled类型的 try &#123; Integer.parseInt(textField.getText()); //将输入的内容转化程int类型，如果输入的字符串不是十进制的话就会触发 //NumberFormateException错误 returnValue = true; &#125; catch (NumberFormatException e) &#123; returnValue = false; &#125; return returnValue; //如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 &#125; &#125;; textField1.setInputVerifier(verifier); frame.add(textField1, BorderLayout.NORTH); frame.add(textField2, BorderLayout.CENTER); frame.setSize(300, 100); frame.setVisible(true); &#125;&#125; 说明：如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 将文本框中的内容保存到文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.FileWriter;import java.io.IOException;class Main extends JFrame &#123; private JTextField textField; private FileWriter writer; public static void main(String args[]) &#123; Main my = new Main(); my.setVisible(true); &#125; public Main() &#123; this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new BorderLayout()); JButton button = new JButton("运行"); JLabel label = new JLabel("name"); textField = new JTextField(); panel.add(label, BorderLayout.WEST); panel.add(textField, BorderLayout.CENTER); String filename = "text.txt"; button.addActionListener(new ActionListener() &#123; //添加一个按钮触发装置，这里只要点击一下anniu就会将文本框中的内容输入到文件中 @Override public void actionPerformed(ActionEvent e) &#123; try &#123; writer = new FileWriter(filename, false); //创建一个写入文件的对象，这里的false表示不在文件的末尾添加 textField.write(writer); //将单行文本中输入的内容写入到文件中 writer.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); System.out.println("false"); &#125; &#125; &#125;); panel.add(button, BorderLayout.SOUTH); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); &#125;&#125; 说明：这里使用的是FileWriter类将内容写入到文件中，详情请看我的上一篇文章 复制、粘贴、剪切文本 这里使用的时copy()、paste()、cut()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class Main &#123; public static void main(String args[]) &#123; final JTextField textField = new JTextField(15); JButton buttonCut = new JButton("Cut"); JButton buttonPaste = new JButton("Paste"); JButton buttonCopy = new JButton("Copy"); JFrame jfrm = new JFrame("Cut, Copy, and Paste"); jfrm.setLayout(new FlowLayout()); jfrm.setSize(230, 150); jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); buttonCut.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.cut(); &#125; &#125;); buttonPaste.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.paste(); &#125; &#125;); buttonCopy.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.copy(); &#125; &#125;); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent ce) &#123; System.out.println("All text: " + textField.getText()); if (textField.getSelectedText() != null) System.out.println("Selected text: " + textField.getSelectedText()); else System.out.println("Selected text: "); &#125; &#125;); jfrm.add(textField); jfrm.add(buttonCut); jfrm.add(buttonPaste); jfrm.add(buttonCopy); jfrm.setVisible(true); &#125;&#125; 说明：这里使用的时用三个按钮监听操作，只需要按住对应的按钮就会触发机制 添加键盘监听机制12345678910111213141516171819202122232425262728293031323334353637383940import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.HeadlessException;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;public class Main extends JFrame &#123; public Main() throws HeadlessException &#123; setSize(200, 200); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLayout(new FlowLayout(FlowLayout.LEFT)); JLabel usernameLabel = new JLabel("Username: "); JTextField usernameTextField = new JTextField(); usernameTextField.setPreferredSize(new Dimension(100, 20)); add(usernameLabel); add(usernameTextField); usernameTextField.addKeyListener(new KeyAdapter() &#123; //创建机制 public void keyReleased(KeyEvent e) &#123; //重载函数，释放按键触发 JTextField textField = (JTextField) e.getSource(); //得到最初发生event的组件对象,既是文本框对象 String text = textField.getText(); textField.setText(text.toUpperCase()); //将所有的小写字母转换成大写字母 &#125; public void keyTyped(KeyEvent e) &#123; //键入时触发 &#125; public void keyPressed(KeyEvent e) &#123; //释放按键时触发的函数 &#125; &#125;); &#125; public static void main(String[] args) &#123; new Main().setVisible(true); &#125;&#125; 添加插入符位置变化的监听机制使用的是CareListener类来实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zzk;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class ClockwiseTextFrame extends JFrame &#123; private JTextField textField; ClockwiseTextPanel clockwiseTextPanel = new ClockwiseTextPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 ClockwiseTextFrame frame = new ClockwiseTextFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public ClockwiseTextFrame() &#123; super(); // 调用超类的构造方法 setTitle("顺时针旋转文字"); // 窗体标题 setBounds(100, 100, 340, 240); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(clockwiseTextPanel); // 将面板类的实例添加到窗体容器中 textField = new JTextField(); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent arg0) &#123; String text = textField.getText();// 获取文本框字符串 clockwiseTextPanel.setText(text);// 为面板中的text变量赋值 &#125; &#125;); getContentPane().add(textField, BorderLayout.SOUTH); &#125; class ClockwiseTextPanel extends JPanel &#123; // 创建内部面板类 private String text; public ClockwiseTextPanel() &#123; setOpaque(false);// 设置面板为透明 setLayout(null);// 设置为绝对布局 &#125; public String getText() &#123; return text; // 获得成员变量的值 &#125; public void setText(String text) &#123; this.text = text;// 为成员变量赋值 repaint();// 调整paint()方法 &#125; public void paint(Graphics g) &#123;// 重写paint()方法 Graphics2D g2 = (Graphics2D) g;// 获得Graphics2D的实例 int width = getWidth();// 获得面板的宽度 int height = getHeight();// 获得面板的高度 if (text != null) &#123; char[] array = text.toCharArray();// 将文本转换为字符数组 int len = array.length * 5;// 定义圆的半径，同时可以调整文字的距离 Font font = new Font("宋体", Font.BOLD, 22);// 创建字体 g2.setFont(font);// 设置字体 double angle = 0;// 定义初始角度 for (int i = 0; i &lt; array.length; i++) &#123;// 遍历字符串中的字符 if (i == 0) &#123; g2.setColor(Color.BLUE);// 第一个字符用蓝色 &#125; else &#123; g2.setColor(Color.BLACK);// 其他字符用黑色 &#125; int x = (int) (len * Math.sin(Math.toRadians(angle + 270)));// 计算每个文字的横坐标位置 int y = (int) (len * Math.cos(Math.toRadians(angle + 270)));// 计算每个文字的纵坐标位置 g2.drawString(array[i] + "", width / 2 + x, height / 2 - y);// 绘制字符 angle = angle + 360d / array.length;// 改变角度 &#125; &#125; &#125; &#125;&#125; 参考文档 官方网站) 英文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy爬取豆瓣全站]]></title>
      <url>%2F2017%2F04%2F08%2Fscrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%85%A8%E7%AB%99%2F</url>
      <content type="text"><![CDATA[Scrapy爬取豆瓣读书全站分析网页 首先打开豆瓣读书中的分类浏览，可以看到其中有很多的分类 豆瓣应该是一个比较好爬的网站，所有的数据都不是ajax加载的，我们打开谷歌的F12或者是火狐的FireBug可以很轻松的找到每一个分类的链接 这里我们使用scrapy中的一个linkextractors库,这个库的作用是会根据提供的限制，自动爬取和深入每一个页面并且提取需要的链接，如果想要找到每一个分类的url,只需Rule(LinkExtractor(allow=&#39;/tag/&#39;,restrict_xpaths=&quot;//div[@class=&#39;article&#39;]&quot;),follow=True),这里的allow是一个正则表达式，用来筛选分类url,restrict_xpaths是限制在哪个结构中筛选url,这里限制的是在&lt;div class=&#39;article&#39;&gt;这个盒模型中，follow表示是否深入，这里当然是要深入,这里就能得到每一个分类url了，自己可以在回调函数中测试下，输入所得的url,可以使用respose.url 得到所有的分类url，就可以继续深入到每一步作品所在的页面了，如下图! 但是我们需要不止是这一页，我们要爬的时全站，因此这里必须实现翻页，我们可以看到页面底部清楚的写着下一页，我们通过解析页面同样可以得到url,如下图所示 可以看到所有的url的规则，我们就可以用正则表达式限制，以获取我们的需要，我们可以写出翻页的代码 1Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), 最后一步就是打开每一部书的网页得到所需的信息了，我们就可以通过这里通过解析网页还是可以很清楚的知道url,这里就不再详细的说怎么解析了，这里可以看到所有的url都在li标签中，如下图 我们打开li标签可以很清楚的看大url的规律，因此这里还是用到上面说的库解析深入，连同上面的代码如下 123Rule(LinkExtractor(allow='/tag/',restrict_xpaths="/ /div[@class='article']"),follow=True),#第一步Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), #第二步翻翻页Rule(LinkExtractor(allow="/subject/\d+/$",restrict_&gt;xpaths="//ul[@class='subject-list']"),callback='parse_item')#得到所需网页的url 到了这里总算是大功告成了，下面就需要解析自己的所需要的信息了,这里附上网页 下面就是写自己解析代码了，这里就不需要详细的说了，详细内容请看源码,值得注意的是爬取的网页速度不要太快，豆瓣会禁IP的，这里可以采用一些反爬虫措施,如请求头的更换，ip地址的更换，下一篇会详细解说。 参考文档： scrapy中文文档 最后附上本人的github地址,不要忘了给个star哦 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇一]]></title>
      <url>%2F2017%2F04%2F06%2FSQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[SQL系列之基本操作新建表 CREATE TABLE [&lt;列名&gt;&lt;数据类型&gt;[表级完整性约束条件]],[&lt;列名&gt;&lt;数据类型&gt;[表级完整性约束条件]]…… 实例 12345CREATE TABLE student(Sno CHAR(9) PRIMARY KEY,Sname CHAR(20) UNIQUE,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20)); 其中student是表名，Sno,Sname,Ssex,Sage,Sdept都是列名，后面的CHAR都是数据类型,这里的PRIMARY KEY是将Sno定义为主键,UNIQUE是将Sname定义为唯一的也就是后面插入数据的时候不能有重复的名字 拓展：主键的定义是在多个候选码中找出那个能够唯一识别一组数据的列名，如果需要两个列名才能识别一组数据，那么可以将这两个列名都定义为主键：PRIMARY KEY(Sno,Sname) 删除表 DROP TABLE NAME;只能删除没有被其他表引用，或者没有建立视图的，这里的引用可以是作为被参照表或者作为参照表 DROP TABLE NAME CASCADE;将全部删除，包括基本表和视图 修改表 添加列 alter table 表名 add 列名 列数据类型 [after 插入位置] 例子 alter table student add grade smallint; //将grade插入到student表中的末尾一列，这里不加after默认的是在末尾添加 alter table studnet add grade smallint after Sname; //这里将grade插入到表中Sname列的后面 删除列alter table 表名 drop 列名 alter table student drop Sname; //输出Sname那一列 修改列alter table 表名 change 列名称 列新名称 新数据类型; 实例 alter table student change Sname name char(10) not null; //修改列名Sname为name,并且还可以修改其中的数据类型，如果想要保持不变，就保持原型。 重命名表alter table 表名 rename 新表名; 实例：alter table student rename STUDENT; //将表名改为STUDENT 插入数据 INSERT INTO table_name(列名,列名，列名....)VALUES(DATA); //这里的data一定要对应每一列的数据类型，当然如果要想要插入所有的数据，就不需要列出所有的列名了 例子: INSERT INTO student(Sno,Sname,Sage,Ssex)values(&#39;201215124&#39;,&#39;jack&#39;,34,&#39;男&#39;); //这里是插入表中的一些列的数据，并且对应了数据类型 INSERT INTO student values(&#39;201215124&#39;,&#39;男&#39;,&#39;jack&#39;,34,&#39;IS&#39;); //这里是按照表中的列名顺序插入数据的 更新数据 update 表名称 set 列名称=新值 where 更新条件; 实例： update student set Sage=Sage+1 where Sno=&#39;12134&#39;; //将Sno为12134的那一列数据的年龄加一 删除表中的数据 delete from 表名称 where 删除条件; 实例： delete from student where Sno=’121314125’; //删除Sno为121314125的那一行数据 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing布局管理器]]></title>
      <url>%2F2017%2F04%2F05%2Fjava%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Swing系列之布局管理器流布局(FlowLayout)默认的JApplet,JPanel,JScrollPane 流布局是相对比较简单的一种布局管理器，也是最常用的布局管理器。在流布局中放置控件时，将按照控件的添加顺序，依次将控件从左到右进行摆放，并且在一行的最后会进行自动换行放置 。在一行中，控件是默认居中放置的。 布局管理器也是通过构造器来创建的。流布局是通过FlowLayout 类来创建，FlowLayout类具有三种构造器。首先是无参构造器， 使用无参构造器能够创建一个默认的以居中对齐方式，控件间水 平和垂直间距为5个像素的流布局。 FlowLayout类还具有一个需要整型参数的构造器，使用该构造器能够创建一个指定对齐方式的流布局管理器，它的控件间水平和垂直间距仍然是默认的5个像素。流布局管理器的对齐方式如下所示。 LEFT 左对齐方式 CENTER 居中对齐方式 RIGHT 右对齐方式 LEADING 控件与容器开始边对齐 TRAILING 构造函数： FlowLayout(),生成一个默认的FlowLayout布局。默认情况下，组件居中，间隙为5个像素。 FlowLayout(int aligment),设定每珩的组件的对齐方式。alignment取值可以为FlowLayout.LEFT,FlowLayout.CENTER,FlowLayout.RIGHT。 FlowLayout(int aligment,int horz, int vert),设定对齐方式，并设定组件的水平间距horz和垂直间距vert，用超类Container的方法setLayout()为容器设定布局。例如，代码setLayout(new FlowLayout())为容器设定 FlowLayout布局。将组件加入容器的方法是add(组件名)。 常用的函数：getAlignment方法和setAlignment方法分别获取和设置流布局管理器的对齐方式。 getHgap方法和setHgap方法分别获取和设置流布局管理器中控件和控件之间的水平间距。getVgap方法和setVgap方法分别获取和 设置流布局管理器中控件和控件之间的垂直间距。12345678910111213141516171819202122232425262728293031import javax.swing.*;import java.awt.*;/** * Created by Chenjiabing on 2017/4/5. */public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame=new JFrame(); FlowLayout flowLayout=new FlowLayout(FlowLayout.LEFT); JPanel panel=new JPanel(flowLayout); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setBounds(100,100,500,400); flowLayout.setHgap(20); //设置水平间距 flowLayout.setVgap(20); //控件之间的垂直间距 for(int i=0;i&lt;6;i++) &#123; JButton button=new JButton("按钮"); panel.add(button); &#125; frame.getContentPane().add(panel); frame.setVisible(true); &#125;&#125; 网格布局(GridLayout) 网络布局也是一种比较常见的布局管理器。使用网格布局管理器后，会将所有的控件尽量按照给出的行数和列数来排列，同时网格布局管理器也会对控件进行尺寸的调整，使所有的控件具有相同的尺寸。在网格布局中，也会尽量使使用的空间成矩形的形式来显示。当窗体发生大小变化时，所有的空间也将自动改变大小来填充窗体。 网格布局是通过GridLayout类来创建的。GridLayout类具有三个构造器，使用无参构造器将创建具有默认行和默认列的网格布局。在创建网格布局管理器时最常用的就是具有两个整型参数的构造器，第一个参数表示网格布局管理器的行数，第二个参数表示网格布局管理器的列数。还有一个具有四个参数的构造器，除了可以定义行数和列数外，还可以定义控件间水平间距和垂直间距。 GridLayout类中还定义了一些方法来对创建的网格布局进行操作 。getRows方法和setRows方法分别是获取和设置网格布局的行数。getColumns方法和setColumns方法分别是获取和设置网格布局 的列数。getHgap方法和setHgap方法分别是获取和设置网格布局 中控件间水平间距。getVgap方法和setVgap方法分别是获取和设 置网络布局中的控件间垂直间距。 构造函数： GridLayout(),生成一个单列的GridLayout布局。默认情况下，无间隙。1.GridLayout(int row,int col),设定一个有行row和列`col的GridLayout布局。 GridLayout(int row,int col,int horz,int vert),设定布局的行数和列数、组件的水平间距和垂直间距 代码大概和上面的设置一样，这里注意的是，网格布局是以行为基准的，如果定义的控件多了或者少了，不会改变行的数量，会根据情况改变列的数量 边框布局(BorderLayout)默认的是JWindow、JFrame,JDialog 上面学习的流布局和网格布局具有很多相似的地方，但是边框布局就和他们存在很大的不同。在使用边框布局时，通常都会由程序员来为控件指定在容器中的位置。边框布局将容器分为五个部分，包括东南西北中五部分。在每一个部分中只能放置一个控件 ，所以如果控件超过五个将不能完全显示。在使用边框布局时需 要注意的是，当容器的大小发生变化时，四周的控件是不会发生变化的，只有中间的控件将发生变化。 边框布局是通过BorderLayout类创建的。BorderLayout类具有两个构造器，一个是无参构造器，另一个是指定控件间间距的构造器，通常使用无参构造器来创建边框布局管理器。 在前面将控件添加到容器中都是通过add方法，将控件作为add方法的参 数来进行添加的。但是在向边框布局容器中添加控件时，这样是不完全 的。在向边框布局容器中添加控件是使用具有两个参数的add方法。其中 第一个参数表示要添加的控件，第二个参数表示要添加到边框布局中的 哪一个位置。边框布局的位置表示是通过常量来表示的，具体常量如下所示 NORTH 容器顶部 SOUTH 容器底部 WEST 容器左边 EAST 容器右边 CENTER 容器的中央 构造函数： BorderLayout(),生成一个默认的BorderLayout布局。默认情况下，没有间隙。 BorderLayout(int horz,int vert),设定组件之间的水平间距和垂直间距。 注意这里还有一些常用的方法，就是设置水平和垂直的间距，上面已经赘述过了，这里就不再详说了 空布局(null) 空布局就是没有使用布局管理器，在空布局的情况下将根据控件的自身信息来为控件指定位置。这就使得控件的布局更加灵活，与此同时给开发人员带来了更大的工作量。 空布局是不需要使用类来创建的，只需要在程序指定布局管理器 为null。将控件添加到空布局容器中时，仍然是使用add方法。因 为这里使用的是空布局管理器，所以在添加控件之前，要对控件 进行设置操作。设置操作是通过setBounds方法来完成的， setBounds方法的基本语法格式如下所示。 public void setBounds(int x,int y,int width,int height); 其中x和y表示的是控件最左上侧的坐标，从而也固定了该控件的 位置。width和height表示的是空间的宽度和高度，从而也指定了控件的大小。 示例代码：1234567&gt;frame.setLayout(null);//布局管理器设置为null JLabel label = new JLabel("First Name:"); label.setBounds(20, 20, 100, 20);//四个参数分别是x,y坐标和label的宽和高 JTextField textField = new JTextField(); textField.setBounds(124, 25, 100, 20); frame.add(label); frame.add(textField); BoxLayout BoxLayout是一种能够实现所有的控件水平放置和垂直放置，因为用到的不多，这里就简单的说一下构造函数：public BoxLayout(Container target,int axis):其中axis表示放置的样式，主要有两种常用到的: X_AXIS:指定组件应该从左到右放置。 Y_AXIS：指定组件从上到下放置 代码 12345678910111213141516171819202122232425262728import oracle.jrockit.jfr.JFR;import javax.swing.*;import java.awt.*;public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame(); // frame.setLayout(new BorderLayout(frame.getComponentCount(),BoxLayout.Y_AXIS)); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); BoxLayout boxLayout = new BoxLayout(panel, BoxLayout.X_AXIS); panel.setLayout(boxLayout); for (int i = 0; i &lt; 10; i++) &#123; JButton button = new JButton("cma"); panel.add(button); &#125; frame.getContentPane().add(panel, BorderLayout.CENTER); // System.out.println(boxLayout.getTarget()); frame.pack(); //frame.setSize(300,200); frame.setVisible(true); &#125;&#125; 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图像处理干货篇一]]></title>
      <url>%2F2017%2F04%2F04%2Fjava%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B9%B2%E8%B4%A7%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java图像处理干货篇绘制图像 绘制图像主要用到的是Graphics类中drawImage方法，当然Graphics2D中也有相应的方法 主要的用法： public abstract boolean drawImage(Image img,x,y,ImageObserver observer):img是Image对象，x,y起始坐标,observer是观察对象 drawImage(Image img,int x,int y,int width,int height,Imageobersver observer):width和height是指定图像的宽度和高度，主要的作用是放大和缩小图像 drawImage(Image img,int dx1,int dy1,int dx2,int dx2,int sx1,int sy1,int sx2,int sy2,ImageObserver observer):主要用来翻转图形,通过互换源矩形的第一个和第二个角的x坐标可以实现水平翻转，通过互换源矩形的第一个和第二个角的y坐标可以实现垂直翻转 翻转图像12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.net.URL;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class PartImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private PartImagePanel imagePanel = null; // 声明图像面板对象 private int dx1, dy1, dx2, dy2; // 目标矩形第一个角与第二个角的X、Y坐标 private int sx1, sy1, sx2, sy2; // 源矩形第一个角与第二个角的X、Y坐标 public static void main(String args[]) &#123; PartImageFrame frame = new PartImageFrame(); frame.setVisible(true); &#125; public PartImageFrame() &#123; super(); URL imgUrl = PartImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 dx2 = sx2 = 340; // 初始化图像大小 dy2 = sy2 = 200; // 初始化图像大小 imagePanel = new PartImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 this.add(imagePanel); // 在窗体中部位置添加图像面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("翻转图像"); // 设置窗体标题 final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton btn_h = new JButton(); btn_h.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sx1和sx2的值 int x = sx1; sx1 = sx2; sx2 = x; imagePanel.repaint(); // 重新调用面板类的paint()方法 &#125; &#125;); btn_h.setText("水平翻转"); panel.add(btn_h); final JButton btn_v = new JButton(); btn_v.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sy1和sy2的值 int y = sy1; sy1 = sy2; sy2 = y; imagePanel.repaint();// 重新调用面板类的paint()方法 &#125; &#125;); btn_v.setText("垂直翻转"); panel.add(btn_v); &#125; // 创建面板类 class PartImagePanel extends JPanel &#123; public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, this);// 绘制图像 &#125; &#125;&#125; 旋转图像 主要用到的是Graphics2D类中的rotate函数，定义如下:public abstract void rotate(double theta): theta是角度，以弧度为单位代码如下 123456789101112131415161718192021222324252627282930package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class RotateImageFrame extends JFrame &#123; private Image img = null; private RotatePanel rotatePanel = null; public RotateImageFrame() &#123; URL imgUrl = RotateImageFrame.class.getResource(&quot;/img/image.jpg&quot;);// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 rotatePanel = new RotatePanel(); // 创建旋转图像的面板对象 this.setBounds(150, 120, 380, 310); // 设置窗体大小和位置 add(rotatePanel);// 在窗体上放置图像面板 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle(&quot;旋转图像&quot;); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new RotateImageFrame().setVisible(true); &#125; class RotatePanel extends JPanel &#123; public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; // 获得Graphics2D对象 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 &#125; &#125;&#125; 倾斜图像 主要用到的是Graphics2D中的shear函数定义如：public abstract void shear(doubel shx,double shy):shx是在正x轴上移动坐标的乘数，它可以作为其纵坐标的值,shy是在正y轴方形移动坐标的乘数，它可以作为其x坐标的函数。本人的理解：倾斜画布，如果shx&gt;0就是向正方向平移，平移的长度为shx*height(图形纵坐标的值，如果是矩形就是乘以矩形的高)相同的对于shy是乘以矩形宽123456789101112131415161718192021222324252627package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class ShearImageFrame extends JFrame &#123; private Image img; private ShearImagePanel canvasPanel = null; public ShearImageFrame() &#123; URL imgUrl = ShearImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 canvasPanel = new ShearImagePanel(); // 创建绘制倾斜图像的面板对象 this.setBounds(100, 100, 360, 240); // 设置窗体大小和位置 add(canvasPanel);// 在窗体上添加面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("倾斜图像"); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new ShearImageFrame().setVisible(true); &#125; class ShearImagePanel extends JPanel &#123;// 绘制倾斜图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2=(Graphics2D) g;// 获得Graphics2D对象 g2.shear(0, -0.5);// 倾斜图像 g2.drawImage(img, 10, 20, 220, 160, this); // 绘制指定大小的图片 &#125; &#125;&#125; 裁剪图片 public BufferedImage createScreenCapture(Rectangle screenRect):返回的是一个BufferedImage对象，参数是Rectangle对象，这个函数是Robot类中的，主要用于裁剪图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zzk;import java.awt.AWTException;import java.awt.BasicStroke;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Image;import java.awt.Rectangle;import java.awt.Robot;import java.awt.Toolkit;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.image.BufferedImage;import java.net.URL;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JSplitPane;public class CutImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private OldImagePanel oldImagePanel = null; // 声明图像面板对象 private int pressPanelX = 0, pressPanelY = 0;// 鼠标按下点的X、Y坐标 private int pressX = 0, pressY = 0;// 鼠标按下点在屏幕上的X、Y坐标 private int releaseX = 0, releaseY = 0;// 鼠标释放点在屏幕上的X、Y坐标 private Robot robot = null; // 声明Robot对象 private BufferedImage buffImage = null; // 声明缓冲图像对象 private CutImagePanel cutImagePanel = new CutImagePanel(); // 创建绘制裁剪结果的面板 private boolean flag = false; // 声明标记变量，为true时显示选择区域的矩形，否则不显示 public static void main(String args[]) &#123; CutImageFrame frame = new CutImageFrame(); frame.setVisible(true); &#125; public CutImageFrame() &#123; super(); URL imgUrl = CutImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 oldImagePanel = new OldImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 final JSplitPane splitPane = new JSplitPane(); splitPane.setDividerLocation((this.getWidth() / 2) - 10); getContentPane().add(splitPane, BorderLayout.CENTER); splitPane.setLeftComponent(oldImagePanel); splitPane.setRightComponent(cutImagePanel); oldImagePanel.addMouseListener(new MouseAdapter() &#123; public void mousePressed(final MouseEvent e) &#123; // 鼠标键按下事件 pressPanelX = e.getX(); // 获得鼠标按下点的X坐标 pressPanelY = e.getY();// 获得鼠标按下点的Y坐标 pressX = e.getXOnScreen() + 1;// 鼠标按下点在屏幕上的X坐标加1，即去除选择线 pressY = e.getYOnScreen() + 1;// 鼠标按下点在屏幕上的Y坐标加1，即去除选择线 flag = true;// 为标记变量赋值为true &#125; public void mouseReleased(final MouseEvent e) &#123; // 鼠标键释放事件 releaseX = e.getXOnScreen() - 1;// 鼠标释放点在屏幕上的X坐标减1，即去除选择线 releaseY = e.getYOnScreen() - 1;// 鼠标释放点在屏幕上的Y坐标减1，即去除选择线 try &#123; robot = new Robot();// 创建Robot对象 if (releaseX - pressX &gt; 0 &amp;&amp; releaseY - pressY &gt; 0) &#123; Rectangle rect = new Rectangle(pressX, pressY, releaseX - pressX, releaseY - pressY);// 创建Rectangle对象 buffImage = robot.createScreenCapture(rect);// 获得缓冲图像对象 cutImagePanel.repaint(); // 调用CutImagePanel面板的paint()方法 &#125; &#125; catch (AWTException e1) &#123; e1.printStackTrace(); &#125; flag = false;// 为标记变量赋值为false &#125; &#125;); oldImagePanel.addMouseMotionListener(new MouseMotionAdapter() &#123; public void mouseDragged(final MouseEvent e) &#123;// 鼠标拖动事件 if (flag) &#123; releaseX = e.getXOnScreen();// 获得鼠标释放点在屏幕上的X坐标 releaseY = e.getYOnScreen();// 获得鼠标释放点在屏幕上的Y坐标 oldImagePanel.repaint();// 调用OldImagePanel面板的paint()方法 &#125; &#125; &#125;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("裁剪图片"); // 设置窗体标题 &#125; class OldImagePanel extends JPanel &#123;// 创建绘制原图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; g2.drawImage(img, 0, 0, this.getWidth(), this.getHeight(), this);// 绘制图像 g2.setColor(Color.WHITE); if (flag) &#123; float[] arr = &#123;5.0f&#125;; // 创建虚线模式的数组 BasicStroke stroke = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 1.0f, arr, 0); // 创建宽度是1的平头虚线笔画对象 g2.setStroke(stroke);// 设置笔画对象 g2.drawRect(pressPanelX, pressPanelY, releaseX - pressX, releaseY - pressY);// 绘制矩形选区 &#125; &#125; &#125; class CutImagePanel extends JPanel &#123;// 创建绘制裁剪结果的面板类 public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(buffImage, 0, 0, releaseX - pressX, releaseY - pressY, this);// 绘制图像 &#125; &#125;&#125; 调整图片的亮度 RescaleOp类中的filter方法原缓冲图像进行重缩放，定义如下public abstract BufferedImage filter(BufferedImage src,BufferedImage dst):src是要过滤的源对象，dst是目标对象，或则为null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.RescaleOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class ImageBrightenFrame extends JFrame &#123; private BufferedImage image;// 用于调整亮度的缓冲图像对象 private BufferedImage oldImage;// 用于存放调整亮度之前的原缓冲图像对象 private ImageBrightenPanel imageBrightenPanel = new ImageBrightenPanel(); public static void main(String args[]) &#123; ImageBrightenFrame frame = new ImageBrightenFrame(); frame.setVisible(true); &#125; public ImageBrightenFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("调整图片的亮度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 oldImage = image;// 存储原来的图像对象，用于以后的恢复操作 getContentPane().add(imageBrightenPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = 5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变亮的效果 repaint();// 重新绘制图像 &#125; &#125;); button.setText("变 亮"); panel.add(button); final JButton button_3 = new JButton(); button_3.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = -5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变暗的效果 repaint();// 重新绘制图像 &#125; &#125;); button_3.setText("变 暗"); panel.add(button_3); final JButton button_2 = new JButton(); button_2.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; image = oldImage; // 获得变亮前的图像 imageBrightenPanel.repaint();// 重新绘制原图像，即恢复为变亮前的图像 &#125; &#125;); button_2.setText("恢 复"); panel.add(button_2); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ImageBrightenPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的RescaleOp类可以调整色数，其原理是每一个样本值乘以一个缩放因子然后加上偏移量就是缩放的数，如果要变亮的话就将偏移量为正，反之为负，这里将缩放因子设置为1.0f是因为不想那么快速的变亮，如果你设置的大一点，就会很快变得很亮，反之亦然 转换彩色图片为灰色图片 主要使用ColorConvertOp类，其构造函数如下public ColorConvertOp(ColorSpace src,ColorSpace dst,RenderingHints hints):src是原颜色空间对象，dst是目标颜色空间对象，hints是用于控制颜色转换的RenderingHints对象，可以为null使用ColorConvertOp类中的filter方法将彩色图像转换成灰色图像，定义如下：public final BufferedImage filter(BufferedImage src,BufferedImage dst):scr要过滤的对象，dst目标空间对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.color.ColorSpace;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.ColorConvertOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class MultiColorToGrayFrame extends JFrame &#123; private BufferedImage image; private ColorToGrayPanel colorToGrayPanel = new ColorToGrayPanel(); public static void main(String args[]) &#123; MultiColorToGrayFrame frame = new MultiColorToGrayFrame(); frame.setVisible(true); &#125; public MultiColorToGrayFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("彩色图像转换为灰度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 getContentPane().add(colorToGrayPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; ColorSpace colorSpace1 = ColorSpace.getInstance(ColorSpace.CS_GRAY);// 创建内置线性为灰度的颜色空间 ColorSpace colorSpace2 = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);// 创建内置线性为 RGB的颜色空间 ColorConvertOp op = new ColorConvertOp(colorSpace1,colorSpace2, null);// 创建进行颜色转换的对象 image = op.filter(image, null);// 对缓冲图像进行颜色转换 repaint();// 重新绘制图像 &#125; &#125;); button.setText("转换为灰度"); panel.add(button); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ColorToGrayPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的image.getGraphics().drawImage(img, 0, 0, null)可以删除的，因为这里Graphics类中的drawImage可以直接绘制BufferedImage类型的缓冲图像，下面会给出一段代码做个示范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import javax.imageio.ImageIO;import javax.swing.*;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;/** * Created by Chenjiabing on 2017/4/5. */public class demo extends JFrame&#123; private BufferedImage image=null; private Graphics2D graphics2D=null; private draw my_draw=new draw(); public static void main(String args[]) &#123; demo my=new demo(); my.setVisible(true); &#125; public demo() &#123; this.setBounds(100,100,1000,1000); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try&#123; image= ImageIO.read(new File("src/img/image.jpg")); //graphics2D=image.createGraphics(); //graphics2D.drawImage(image,0,0,null); // image.getGraphics().drawImage(image,0,0,null); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("error"); &#125; this.getContentPane().add(my_draw); &#125; class draw extends JPanel &#123; public void paint(Graphics g) &#123; g.drawImage(image,0,0,image.getWidth(),image.getHeight(),this); &#125; &#125;&#125; 总结： 从文件中读取图像的方法 URL imgUrl = CutImageFrame.class.getResource(“/img/image.jpg”);//得到的是URL img = Toolkit.getDefaultToolkit().getImage(imgUrl); //得到的是Image对象，同样的想要得到BufferedImage对象可以进行转 化 Image img=ImageIo(new File(&quot;path&quot;));这里得到的是Image对象，如果想要得到BufferedImage对象，可以用BufferedImage的构造方法BufferedImage(int width,int height,) 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib绘制图形基础]]></title>
      <url>%2F2017%2F04%2F01%2Fmatplotlib%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[matplotlib绘制基本图形折线图12345678import matplotlib.pyplot as pltimport numpy as npx=np.arange(0,10,1) #创建一个0-10之间以1为间隔的numpy数组y=x+10 plt.plot(x,y,color='red',linestyle='--',marker='&gt;',linewidth=3,label='example one') #绘制图形plt.savefig('first.png',dpi=50) #保存图形，dpi表示plt.legend() #显示图例plt.show() #显示图形 图形展示说明plt.plot()可以直接绘制折线，其中marker是折线上的标记，linewidth是折线的宽度，label是图例，如果要想显示就要设置plt.legend(),linestyle是折线的风格，color是颜色 饼状图123456789101112131415import matplotlib.pyplot as pltslices = [2,3,4,9] #指定每一个切片的大小，这里就是每块的比例activities = ['sleeping','eating','working','playing'] #指定标签cols = ['c','m','r','b'] #y颜色plt.pie(slices, labels=activities, colors=cols, #指定每一个区块的颜色 startangle=90, #开始角度，默认是0度，从x轴开始，90度从y轴开始 shadow= True, #阴影效果 explode=(0,0.1,0,0), #拉出第二个切片，如果全为0就不拉出，这里的数字是相对与圆心的距离 autopct='%1.1f%%') #显示百分比plt.title('Interesting Graph\nCheck it out') #设置标题plt.show() 图片展示 散点图12345678import numpy as npimport matplotlib.pyplot as pltx=np.random.rand(1000)y=np.random.rand(len(x))plt.scatter(x,y,color='r',alpha=0.3,label='example one',marker='o') #绘图plt.legend()#plt.axis([0,2,0,2]) #设置坐标的范围plt.show() 图片展示 直方图123456789import matplotlib.pyplot as pltimport numpy as npx=np.random.randint(1,1000,200)axis=plt.gca() #得到当前的绘图对象axis.hist(x,bins=35,facecolor='r',normed=True,histtype='bar',alpha=0.5)#bins表示直方图的个数，histtype表示直方图的样式，normed如果为True就将直方归一化，显示概率密度，默认是Falseaxis.set_xlabel("Values") #设置x的标签axis.set_ylabel("Frequency") axis.set_title("HIST")plt.show() 图片展示 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSplitPane(分割面板)]]></title>
      <url>%2F2017%2F03%2F28%2FSwing%E4%B8%AD%E7%9A%84JSplitPane%2F</url>
      <content type="text"><![CDATA[Swing中的JSplitPane(分割面板)引言 JSplitPane 用于分隔两个（只能两个）Component。两个 Component 图形化分隔以外观实现为基础，并且这两个 Component 可以由用户交互式调整大小。有关如何使用 JSplitPane 的信息，请参阅 The Java Tutorial 中的 How to Use Split Panes 一节。 使用 JSplitPane.HORIZONTAL_SPLIT 可让分隔窗格中的两个 Component 从左到右排列，或者使用 JSplitPane.VERTICAL_SPLIT 使其从上到下排列。改变 Component 大小的首选方式是调用 setDividerLocation，其中 location 是新的 x 或 y 位置，具体取决于 JSplitPane 的方向。 要将 Component 调整到其首选大小，可调用 resetToPreferredSizes。 当用户调整 Component 的大小时，Component 的最小大小用于确定 Component 能够设置的最大/最小位置。如果两个组件的最小大小大于分隔窗格的大小，则分隔条将不允许您调整其大小。改变 JComponent 最小大小，请参阅 JComponent.setMinimumSize(java.awt.Dimension)。 当用户调整分隔窗格大小时，新的空间以 resizeWeight 为基础在两个组件之间分配。默认情况下，值为 0 表示右边/底部的组件获得所有空间，而值为 1 表示左边/顶部的组件获得所有空间。补充说明： 这里的JComponebt.SetMinimumSize(java.awt.Dimension):用于设置组件的最小值，这里的Dimension是一个封装组件的高度和宽度的一个类，其中的一个构造函数就是Dimension(int width,int height),详情见文档，当然有设置最小的就有设置最大的啊，详情看文档吧 构造函数 public JSplitPanel():创建一个配置为将其子组件水平排列、无连续布局、为组件使用两个按钮的新 JSplitPane public JSplitPanel(int newOrientation):创建一个指定方向的分割板，这里的newOrientation可以设置两个值， VERTICAL_SPLIT(设置分割板为上下布局),HORIZONTAL_SPLIT(设置分隔板左右布局) public JSplitPane(int newOrientation,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向和不连续重绘的指定组件的新 JSplitPane。 public JSplitPane(int newOrientation,boolean newContinuousLayout,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向、重绘方式和指定组件的新 JSplitPane。 常用方法 setContinuousLayout(boolean newContinuousLayout):设置是否连续重新显示组件，如果为false就会发现在调整面板的过程中会显示一道黑线，只有当停下的时候才能正常的显示，默认是false setDividerSize(int newSize):设置分割条的大小* setDividerLocation(double size):设置分隔条的位置,这里的size是小数，个人觉得官方文档好像这里有点对劲，相当于占整个面板的百分比 setLeftComponent(Componentcomp)/setTopComponent(Component comp): 将组件设置到分隔条的上面或者左边。 setRightComponent(Component comp)/setBottomComponent(Component comp):将组件设置到分隔条的下面或者右边。 setOneTouchExpandable(boolean newValue):设置 oneTouchExpandable 属性的值，要使 JSplitPane 在分隔条上提供一个 UI 小部件来快速展开/折叠分隔条，此属性必须为 true。 补充说明： 上面只是常用的几个函数，具体的请看官方文档，注意这里的setLeftComponent的四个设置组件的函数要根据分隔板的分布来确定 开始撸代码 初步实现(创建两个按钮实现分隔板的布局)12345678910111213141516171819202122232425262728import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent topButton = new JButton("Left"); JComponent bottomButton = new JButton("Right"); final JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setTopComponent(topButton); splitPane.setBottomComponent(bottomButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); splitPane.setDividerLocation(0.5); &#125;&#125; 更进一步(两种布局的操作)123456789101112131415161718192021222324import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent leftButton = new JButton("Left"); JComponent rightButton = new JButton("Right"); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setLeftComponent(leftButton); splitPane.setRightComponent(rightButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); &#125;&#125; 嵌套分隔板12345678910111213141516171819202122232425262728293031323334import javax.swing.JApplet;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JSplitPane;public class Main&#123; public static void main(String[] a) &#123; int HORIZSPLIT = JSplitPane.HORIZONTAL_SPLIT; int VERTSPLIT = JSplitPane.VERTICAL_SPLIT; boolean continuousLayout = true; JLabel label1 = new JLabel("a"); JLabel label2 = new JLabel("b"); JLabel label3 = new JLabel("c"); JSplitPane splitPane1 = new JSplitPane(VERTSPLIT, continuousLayout, label1, label2); splitPane1.setOneTouchExpandable(true); splitPane1.setDividerSize(2); splitPane1.setDividerLocation(0.5); JSplitPane splitPane2 = new JSplitPane(HORIZSPLIT, splitPane1, label3);//将分隔板和一个label放在第二个分割板中实现嵌套 splitPane2.setOneTouchExpandable(true); splitPane2.setDividerLocation(0.4); splitPane2.setDividerSize(2); JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(splitPane2); frame.pack(); frame.setVisible(true); &#125;&#125; 事件监听12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.awt.BorderLayout;import java.beans.PropertyChangeEvent;import java.beans.PropertyChangeListener;// w w w . j a va2s . co mimport javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Property Split"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setContinuousLayout(true); splitPane.setOneTouchExpandable(true); JComponent topComponent = new JButton("A"); splitPane.setTopComponent(topComponent); JComponent bottomComponent = new JButton("B"); splitPane.setBottomComponent(bottomComponent); PropertyChangeListener propertyChangeListener = new PropertyChangeListener() &#123; public void propertyChange(PropertyChangeEvent changeEvent) &#123; JSplitPane sourceSplitPane = (JSplitPane) changeEvent.getSource(); String propertyName = changeEvent.getPropertyName(); if (propertyName.equals(JSplitPane.LAST_DIVIDER_LOCATION_PROPERTY)) &#123; int current = sourceSplitPane.getDividerLocation(); System.out.println("Current: " + current); Integer last = (Integer) changeEvent.getNewValue(); System.out.println("Last: " + last); Integer priorLast = (Integer) changeEvent.getOldValue(); System.out.println("Prior last: " + priorLast); &#125; &#125; &#125;; splitPane.addPropertyChangeListener(propertyChangeListener); frame.add(splitPane, BorderLayout.CENTER); frame.setSize(300, 150); frame.setVisible(true); &#125;&#125; 说明无论 bean 何时更改 bound 属性，都会激发一个 PropertyChange 事件。可以向源 bean 注册一个 PropertyChangeListener，以便获得所有绑定 (bound) 属性更改的通知。 类 PropertyChangeEvent无论 bean 何时更改 “bound” 或 “constrained” 属性，都会提交一个 “PropertyChange” 事件。PropertyChangeEvent 对象被作为参数发送给 PropertyChangeListener 和 VetoableChangeListener 方法。通常 PropertyChangeEvent 还附带名称和已更改属性的旧值和新值。如果新值是基本类型（比如 int 或 boolean），则必须将它包装为相应的 java.lang.* Object 类型（比如 Integer 或 Boolean）。如果旧值和新值的真实值是未知的，则可能为它们提供 null 值。事件源可能发送一个 null 对象作为名称，以指示其属性的任意事件集已更改。在这种情况下，旧值和新值应该仍然为 null。getSource():返回最初未变化的对象，未Object类型的,因此这里需要强制转换成JSplitPanel 参考文章 官方文档 英文Swing教程 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSlider(滑块)]]></title>
      <url>%2F2017%2F03%2F27%2FSwing-%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJSlider%2F</url>
      <content type="text"><![CDATA[Swing干货系列之JSlider(滑块)引言 一个让用户以图形方式在有界区间内通过移动滑块来选择值的组件。 滑块可以显示主刻度标记以及主刻度之间的次刻度标记。刻度标记之间的值的个数由 setMajorTickSpacing和 setMinorTickSpacing 来控制。刻度标记的绘制由 setPaintTicks 控制。 滑块也可以在固定时间间隔（或在任意位置）沿滑块刻度打印文本标签。标签的绘制由 setLabelTable 和 setPaintLabels 控制。 构造函数 JSlider():创建一个空值的滑块组件，但是默认的刻度是100，其中如果获得其值的话可以很清楚的看见 JSlider(BoundedRangeModel brm):使用指定的 BoundedRangeModel 创建一个水平滑块 JSlider(int min,int max):创建一个带有最小值和最大值得滑块 JSlider(int min,int max,int value):创建一个带有最小值，最大值和当前值的滑块 常用的方法 getValue(int x)/setValue(int x):得到和设置当前值 getPaintsLabels():return boolean 告知是否绘制了签 SetFont(Font font):设置组件的字体，其中Font类的font对象是参数 setInverted(boolean b):反转滑块的刻度 setMaximum(int maximum) ：设置最大值 setMinimum(int min):设置最小值 setMinorTickSpacing(int n) :设置次刻度，就是主刻度中间不用标记数值的刻度 setMajorTickSpacing(int n):设置主刻度 setPaintTicks(boolean b):确定是否在滑块下面显示刻度线，如果为false表示不显示 setPaintLabels(boolean b):确定是否在刻度线下绘制数值，默认不绘制以上只是列了几个常用的函数，详情见官方文档 下面撸个代码试试身手12345678910111213141516171819202122232425262728293031323334353637383940package com;import javax.swing.*;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import java.awt.*;/** * Created by chenjiabing on 2017/3/27. */public class Java_swing extends JFrame &#123; public JSlider points = null; public Java_swing() &#123; super(); setTitle("记事本"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(300, 400);// points=new JSlider(); points = new JSlider(0, 50, 5); points.setMinorTickSpacing(5);//设置次要的间隔，每个一个间隔，这个显示时中间不标记数值 points.setMajorTickSpacing(10);//显示主要的刻度线，每个两个间隔，这个设置了，如果setPaintLabels为true就会显示数值 points.setPaintTicks(true); //确定是否显示刻度线 points.setPaintLabels(true); //确定是否显示刻度的值 //points.setInverted(true);//指定为true反转刻 度 points.setSnapToTicks(true); points.addChangeListener(new ChangeListener() &#123; @Override public void stateChanged(ChangeEvent e) &#123; int value = points.getValue(); System.out.println(value); &#125; &#125;); getContentPane().add(points, BorderLayout.CENTER); &#125; public static void main(String args[]) &#123; Java_swing my = new Java_swing(); my.setVisible(true); &#125;&#125; Change Listener(一个监听机制)1234567891011121314151617181920212223242526272829303132333435import java.awt.Dimension;/*from w ww . ja v a 2 s .c o m*/import javax.swing.JFrame;import javax.swing.JSlider;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;public class Main &#123; public static void main(String[] args) &#123; JFrame f = new JFrame(); final JSlider slider = new JSlider(0, 150, 0); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); slider.setPreferredSize(new Dimension(150, 30)); //添加change Listener,当然这里的和JButton的也是一样，可以在一个类中实现 slider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent event) &#123; int value = slider.getValue(); if (value == 0) &#123; System.out.println("0"); &#125; else if (value &gt; 0 &amp;&amp; value &lt;= 30) &#123; System.out.println("value &gt; 0 &amp;&amp; value &lt;= 30"); &#125; else if (value &gt; 30 &amp;&amp; value &lt; 80) &#123; System.out.println("value &gt; 30 &amp;&amp; value &lt; 80"); &#125; else &#123; System.out.println("max"); &#125; &#125; &#125;); f.add(slider); f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); &#125;&#125; 当然以上只是JSlider的一部分内容，还有的后面会陆续更新本文参考的文章： 中文文档 英文文档 福利时间，博主写了一个小例子，想要的朋友可以参见github,不要忘了随手点个赞哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置请求池]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[scrapy设置”请求池”引言 相信大家有时候爬虫发出请求的时候会被ban，返回的是403错误，这个就是请求头的问题，其实在python发出请求时，使用的是默认的自己的请求头，网站管理者肯定会不允许机器访问的，但是有些比较low的网站还是可以访问的，有时候网站管理者看到同一个请求头在一秒内请求多次，傻子都知道这是机器在访问，因此会被ban掉，这时就需要设置请求池了，这个和ip代理池是一个概念 爬虫请求常见的错误 200：请求成功 处理方式：获得响应的内容，进行处理201：请求完成，结果是创建了新资源。新创建资源的 URI 可在响应的实体中得到 处理方式：爬虫中不会遇到202：请求被接受，但处理尚未完成 处理方式：阻塞等待204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被 HTTP/1.0 的应用程序直接使用， 只是作为 3XX 类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的 URL，这样就可以在将来通过该 URL 来访问此资源 处理方式：重定向到分配的 URL302：请求到的资源在一个不同的 URL 处临时保存 处理方式：重定向到临时的 URL304 请求的资源未更新 处理方式：丢弃400 非法请求 处理方式：丢弃401 未授权 处理方式：丢弃403 禁止 处理方式：丢弃404 没有找到 处理方式：丢弃5XX 回应代码以“5”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求 处理方式：丢弃 话不多说直接撸代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from scrapy import logimport randomfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddlewareclass RotateUserAgentMiddleware(UserAgentMiddleware):# for more user agent strings,you can find it in http://www.useragentstring.com/pages/useragentstring.phpuser_agent_list = [ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1", "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 " "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5", "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"]def process_request(self, request, spider): ua = random.choice(self.user_agent_list) if ua: # 显示当前使用的useragent print "********Current UserAgent:%s************" % ua # 记录 log.msg('Current UserAgent: ' + ua) request.headers.setdefault('User-Agent', ua) 说明 这里的思路就是在下载器中间件中对request设置请求，这里是使用request.headers.setdefault(&quot;User-Agent&quot;,user_agent)这个函数设置请求头，对于下载器中间件在我博客前面的文章已经有说明，想要了解的请点击 注意 这里还要说明的是设置了请求池还要在配置文件settins中设置一下，具体设置方法和设置代理ip一样，详情请看scrapy代理ip的设置 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录]]></title>
      <url>%2F2017%2F03%2F26%2FScrapy%E4%B8%AD%E4%BD%BF%E7%94%A8cookie%E5%85%8D%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%2F</url>
      <content type="text"><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录引言 python爬虫我认为最困难的问题一个是ip代理，另外一个就是模拟登录了，更操蛋的就是模拟登录了之后还有验证码，真的是不让人省心，不过既然有了反爬虫，那么就有反反爬虫的策略，这里就先介绍一个cookie模拟登陆，后续还有seleminum+phantomjs模拟浏览器登录的文章。还不知道cookie是什么朋友们，可以点击这里 cookie提取方法： 打开谷歌浏览器或者火狐浏览器，如果是谷歌浏览器的按F12这个键就会跳出来浏览器控制台，然后点击Network，之后就是刷新网页开始抓包了，之后在抓到的页面中随便打开一个，就能看到cokie了，但是这里的cookie并不符合python中的格式，因此需要转换格式，下面提供了转换的代码 1234567891011121314151617181920212223# -*- coding: utf-8 -*-class transCookie:def __init__(self, cookie): self.cookie = cookiedef stringToDict(self): ''' 将从浏览器上Copy来的cookie字符串转化为Scrapy能使用的Dict :return: ''' itemDict = &#123;&#125; items = self.cookie.split(';') for item in items: key = item.split('=')[0].replace(' ', '') value = item.split('=')[1] itemDict[key] = value return itemDictif __name__ == "__main__":cookie = "你复制的cookie"trans = transCookie(cookie)print trans.stringToDict() 补充说明： 只需要将你网页上的cookie复制到上述代码中直接运行就可以了 使用cookie操作scrapy 直接撸代码 123456789101112131415161718# -*- coding: utf-8 -*-import scrapyfrom scrapy.conf import settings #从settings文件中导入Cookie，这里也可以室友from scrapy.conf import settings.COOKIEclass DemoSpider(scrapy.Spider):name = "demo"#allowed_domains = ["csdn.com"]start_urls = ["http://write.blog.csdn.net/postlist"]cookie = settings['COOKIE'] # 带着Cookie向网页发请求\headers = &#123; 'Connection': 'keep - alive', # 保持链接状态 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'&#125;def start_requests(self): yield scrapy.Request(url=self.start_urls[0],headers=self.headers,cookies=self.cookie)# 这里带着cookie发出请求def parse(self, response): print response.body 说明 这里是scrapy工程目录下spiders目录下的主要的解析网页的py文件相信学过scrapy的应该不会陌生，上述代码中的cookie值是放在Settings文件中的，因此使用的时候需要导入，当然你也可以直接将cookie粘贴到这个文件中 注意 虽说这里使用直接使用cookie可以省去很多麻烦，但是cookie的生命周期特别的短，不过小型的项目足够使用了，向那些需要爬两三天甚至几个月的项目就不适用了，因此在隔一段时间就要重新换cookie的值，虽说有很多麻烦，但是我还是比较喜欢这种方法的，因为可以省去不少脑筋 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持。 最后欢迎大家看看我的其他scrapy文章 scrapy设置代理ip scrapy架构初探 scrapy初试 scrapy下载器中间件 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置代理ip]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86ip%2F</url>
      <content type="text"><![CDATA[scrapy代理的设置 在我的上一篇文章介绍了scrapy下载器中间件的使用,这里的scrapyIP的代理就是用这个原理实现的，重写了下载器中间件的process_request(self,request,spider)这个函数,这个函数的主要作用就是对request进行处理。 话不多说直接撸代码 123456789101112131415161718192021222324import random import scrapyimport loggingclass proxMiddleware(object):#proxy_list=[&#123;'http': 'http://123.157.146.116:8123'&#125;, &#123;'http': 'http://116.55.16.233:8998'&#125;, &#123;'http': 'http://115.85.233.94:80'&#125;, &#123;'http': 'http://180.76.154.5:8888'&#125;, &#123;'http': 'http://139.213.135.81:80'&#125;, &#123;'http': 'http://124.88.67.14:80'&#125;, &#123;'http': 'http://106.46.136.90:808'&#125;, &#123;'http': 'http://106.46.136.226:808'&#125;, &#123;'http': 'http://124.88.67.21:843'&#125;, &#123;'http': 'http://113.245.84.253:8118'&#125;, &#123;'http': 'http://124.88.67.10:80'&#125;, &#123;'http': 'http://171.38.141.12:8123'&#125;, &#123;'http': 'http://124.88.67.52:843'&#125;, &#123;'http': 'http://106.46.136.237:808'&#125;, &#123;'http': 'http://106.46.136.105:808'&#125;, &#123;'http': 'http://106.46.136.190:808'&#125;, &#123;'http': 'http://106.46.136.186:808'&#125;, &#123;'http': 'http://101.81.120.58:8118'&#125;, &#123;'http': 'http://106.46.136.250:808'&#125;, &#123;'http': 'http://106.46.136.8:808'&#125;, &#123;'http': 'http://111.78.188.157:8998'&#125;, &#123;'http': 'http://106.46.136.139:808'&#125;, &#123;'http': 'http://101.53.101.172:9999'&#125;, &#123;'http': 'http://27.159.125.68:8118'&#125;, &#123;'http': 'http://183.32.88.133:808'&#125;, &#123;'http': 'http://171.38.37.193:8123'&#125;]proxy_list=[ "http://180.76.154.5:8888", "http://14.109.107.1:8998", "http://106.46.136.159:808", "http://175.155.24.107:808", "http://124.88.67.10:80", "http://124.88.67.14:80", "http://58.23.122.79:8118", "http://123.157.146.116:8123", "http://124.88.67.21:843", "http://106.46.136.226:808", "http://101.81.120.58:8118", "http://180.175.145.148:808"]def process_request(self,request,spider): # if not request.meta['proxies']: ip = random.choice(self.proxy_list) print ip #print 'ip=' %ip request.meta['proxy'] = ip 主要的原理： 给出一个代理列表，然后在这个列表中随机取出一个代理，设置在request中，其中request.meta[&#39;proxy&#39;]就是设置代理的格式 但是现在主要的问题就是没有代理ip可用，如果去买的话又太贵了，自己玩玩买代理不值当，所以只好自己写爬虫去爬取免费的代理了，但是免费的代理存活的时间是有限的，这是个非常麻烦的事情，我提供的方法就是实现自己的一个ip代理池，每天定时更新自己的代理池，具体的实现方法会在下一篇文章中介绍，现在提供一段代码用来爬取西刺网站的代理 直接撸代码，接招吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import requestsfrom bs4 import BeautifulSoupimport threadingimport Queueclass Get_ips():def __init__(self,page): self.ips=[] self.urls=[] for i in range(page): self.urls.append("http://www.xicidaili.com/nn/" + str(i)) self.header = &#123;"User-Agent": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'&#125; #self.file=open("ips",'w') self.q=Queue.Queue() self.Lock=threading.Lock()def get_ips(self): for url in self.urls: res = requests.get(url, headers=self.header) soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all("td") ip_temp = "http://" + tds[1].contents[0] + ":" + tds[2].contents[0] # print str(ip_temp) self.q.put(str(ip_temp))def review_ips(self): while not self.q.empty(): ip=self.q.get() try: proxy=&#123;"http": ip&#125; #print proxy res = requests.get("http://www.baidu.com", proxies=proxy,timeout=5) self.Lock.acquire() if res.status_code == 200: self.ips.append(ip) print ip self.Lock.release() except Exception: pass #print 'error'def main(self): self.get_ips() threads=[] for i in range(40): threads.append(threading.Thread(target=self.review_ips,args=[])) for t in threads: t.start() for t in threads: t.join() return self.ipsdef get_ip():my=Get_ips(4)return my.main()get_ip() 实现的原理 这里用到了BeautifulSoup解析页面，然后将提取到的代理交给队列，然后再通过共享队列分配给线程，这里主要开启线程通过设置代理ip访问一个网站，因为访问网站的时间比较长，因此要开起多个线程，相信大家能够学习设置代理ip了应该都是比较上手的了，这里具体的代码就不一一解释了，如果代码有什么问题可以及时联系我，我的联系方式在关于我的一栏中有提到 补充 想要ip应用起来，还要在配置文件settings中添加DOWNLOADER_MIDDLEWARES = { &#39;demo.proxy.proxMiddleware&#39;:400 }这里的demo是工程的名字，proxy是py文件的名,proxMiddleware是类的名字 当然这里可能你觉得proxy_list写在这里有点冗余，你可以在配置文件中定义，然后将配置文件的内容import到py文件中 以上全是博主慢慢摸索出来的，可以说自学一门技术真的很难，学习python爬虫已经有两三个月了，可以说全是自己通过看项目，网上查资料才有了今天的成功，不过现在还有几个问题没有解决，就是分布式爬虫、移动端爬取，博主接下来就要主攻这两个方面，学好之后会在自己的博客上分享学习心得的，因为网上没有系统的学习教程，对于自学的人来说实在是太痛苦了 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy的下载器中间件]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%99%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[scrapy中的下载器中间件下载中间件 下载器中间件是介于Scrapy的request/response处理的钩子框架。 是用于全局修改Scrapy request和response的一个轻量、底层的系统。 编写下载器中间件 1. process_request(request, spider)当每个request通过下载中间件时，该方法被调用。process_request() 必须返回其中之一: 返回 None 、返回一个 Response 对象、返回一个 Request对象或raise IgnoreRequest 。 如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。 如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。 如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。 如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request 对象) – 处理的request spider (Spider 对象) – 该request对应的spider 2. process_response(request, response, spider) process_response() 必须返回以下之一: 返回一个 Response对象、 返回一个Request 对象或raise一个 IgnoreRequest 异常。 如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。 如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。 如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request对象) – response所对应的request response (Response 对象) – 被处理的response spider (Spider 对象) – response所对应的spider 3.process_exception(request, exception, spider) 当下载处理器(download handler)或 process_request() (下载中间件)抛出异常(包括 IgnoreRequest 异常)时， Scrapy调用 process_exception() 。 process_exception() 应该返回以下之一: 返回 None 、 一个 Response 对象、或者一个 Request 对象。 如果其返回 None ，Scrapy将会继续处理该异常，接着调用已安装的其他中间件的 process_exception() 方法，直到所有中间件都被调用完毕，则调用默认的异常处理。 如果其返回一个 Response 对象，则已安装的中间件链的 process_response() 方法被调用。Scrapy将不会调用任何其他中间件的 process_exception() 方法。 如果其返回一个 Request 对象， 则返回的request将会被重新调用下载。这将停止中间件的 process_exception() 方法执行，就如返回一个response的那样。 参数: request (是 Request 对象) – 产生异常的request exception (Exception 对象) – 抛出的异常 spider (Spider 对象) – request对应的spider 总结： 总的来说下载器中间件就是起到处理request请求并且返回response的作用，一切从网页爬取的url发起的请求会组成一个请求队列，然后一个一个排队经过下载器中间件，之后下载器中间件会对request做出相应的处理，比如添加请求头，添加代理等等，然后通过process_response返回一个response，之后就是用得到的response做出相应的分析，当然这里的内容页可以不实现，但是如果要爬取大型的网站，会遇到被ban的可能就要在下载器中间件这里着手，设置一些相应的请求头，ip代理等等内容。以上纯属个人逐渐摸索总结出来的内容，如果有什么错误欢迎指正 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy初试]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[scrapy初试 创建项目 打开cmd，在终端输入scrapy startproject tutorial,这里将在指定的文件夹下创建一个scrapy工程 其中将会创建以下的文件： scrapy.cfg: 项目的配置文件 tutorial/: 该项目的python模块。之后您将在此加入代码。 tutorial/items.py: 项目中的item文件. tutorial/pipelines.py: 项目中的pipelines文件. tutorial/settings.py: 项目的设置文件. tutorial/spiders/: 放置spider代码的目录. 定义item Item是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单) 首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 tutorial 目录中的 items.py 文件: 12345import scrapyclass DmozItem(scrapy.Item):title = scrapy.Field()link = scrapy.Field()desc = scrapy.Field() 一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义. 编写第一个爬虫 在工程的根目录下打开终端输入scrapy genspider demo douban.com这里的demo是spders文件下的主要py文件douban.com是要爬取的域名，会在demo.py中的 allowed_domains中显示，主要的功能就是限制爬取的url spider代码中内容解析 name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request对象。 以下是spider目录下的demo.py的代码 1234567891011121314import scrapyclass DmozSpider(scrapy.Spider):name = "dmoz"allowed_domains = ["dmoz.org"]start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"]def parse(self, response): filename = response.url.split("/")[-2] with open(filename, 'wb') as f: f.write(response.body) spider的爬取 进入工程的根目录下打开终端输入：scrapy crawl dmoz spider中的数据存取 在工程的根目录下打开终端输入scrapy crawl dmoz -o items.json这里是将数据存储到json文件中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中的IO操作]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E4%B8%AD%E7%9A%84IO%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[java中IO操作读取文件中的内容 使用Scanner读取文本中的内容 相信大家都知道Scanner console=new Scanner(System.in)是用来读取控制台上输入的内容，但是这里是用来读取文件的内容，原理是一样的，只是对象不同罢了，这里用到的是File对象，用来创建一个文件对象 123456Scanner input=new Scanner(new File("hello.txt"));//创建一个对象inputwhile(input.hasNextLine()) //这里用来判断是否还有内容， 以免读到最后发生错误&#123;String content=input.nextLine();System.out.println(content);&#125; 这里顺便补充一下Scannner中的几个函数： nextLine():读取一行的内容，包括空格，换行 nextInt():读取一个整型内容 nexDouble():读取一个双精度的浮点数 next():读取下一个内容，无论什么类型，其中遇到空格和换行默认是一个标记（即是跳过）和nextLine()类似 hasNext():用来判断文件中的还有下一个内容，无论什么类型的 hasNextInt() hasNextDouble()://相似，不在赘述 使用FileReader读取 用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream上构造一个 InputStreamReader。FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。 //这里使用new File创建一个对象，同样的也可以直接将文件的绝对路径传入 FileReader file=new FileReader(new File(&quot;hello.txt&quot;)); while(file.ready()) //用来判断是否还有字符可读 { int content=file.read(); //这里的read是读取将单个字符 返回的是int，即是ascii码,这里官方文档说返回的是读取的字符数，但是我实验了一下返回的ascii码 System.out.println((char)content); //所以要将ascii码转换成字符 } file.close(); 常用的几个方法： read(): return int 上面介绍过 read(char[] cbuf,int int length):将内容读入到一个char类型的数组，length是读取的字符数，offest是偏移量 使用BufferedReader的类实现高效的读取文件 123456//传入一个reader创建一个对象 BufferedReader file= new BufferedReader(new FileReader("hello.txt")); System.out.println(file.skip(3));//实现将指针跳过3个字符 System.out.println((char)file.read()); //read的方法，和FileReader中的read一样 String line=file.readLine(); //读取一行 System.out.println(line); 常用的方法： readLine() read()：如果到了末尾返回-1 read(char [],int off,int length):和FileReader中的一样 ready():判断是否还可以读取，一般和read配对使用 skip(long n):跳过的字符数 close() 文件的写入 用FileWriter写入文件 12345/*创建将对象f传入FileWriter,其中Filewriter有两个参数，第一个是File对象后者是一个String(即是文件的路径），第二个参数是boolean类型的，表示是否在文件的末尾追加内容，默认的是false表示不用在末尾追加，如果想要在末尾追加要写入另外一个参数true,当然这里可以用更加简洁的方式创建：FileWriter file=new FileWriter("hello.txt",false);*/FileWriter file=new FileWriter(f,true);file.write("chenjiabing");//写入函数writefile.close(); //最后必须关闭文件的输入流，否则写入将会失败，这里不想c和c++ 其中Filewriter中的方法还有 flush：刷新缓存流 close append():当前的领会的就是写入数组:append(Arrays.toString(list)); getEncoding():返回此流使用的字符编码 用PrintStream写入文件 这里同样的是和System.out.println()一样的原理，System.out.println只是内部实现了PrintStream，这里是用来将指定的内容写入到文件中而已 12345PrintStream output=new PrintStream(new File("hello.txt"));//创建一个写入的对象outputoutput.print("flan");output.println("vmlkfamla");output.println("vmslfkmadvmfs;dm"); 这里是用BufferedWriter类写入文件(一个高效的写入方式) 简单介绍 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。该类提供了 newLine() 方法，它使用平台自己的行分隔符概念，此概念由系统属性 line.separator 定义。并非所有平台都使用新行符 (‘\n’) 来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。通常 Writer 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。例如， PrintWriter out= new PrintWriter(new BufferedWriter(new FileWriter(&quot;foo.out&quot;))); 将缓冲 PrintWriter对文件的输出。如果没有缓冲，则每次调用 print() 方法会导致将字符转换为字节，然后立即入到文件，而这是极其低效的。 例子 12345BufferedWriter input=new BufferedWriter(new FileWriter("hello.txt")); input.write("这是一个文件读入的方法"); input.newLine(); input.write("一个高效的方法"); input.close(); 其他的方法 close() flush() newLine():写入一个换行，因为每一个操作系统上的换行符可能不一样，不能系统的都用”\n”表示 write() 详情参见API 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy架构初探]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[scrapy架构初探引言 Python即时网络爬虫启动的目标是一起把互联网变成大数据库。单纯的开放源代码并不是开源的全部，开源的核心是“开放的思想”，聚合最好的想法、技术、人员，所以将会参照众多领先产品，比如，Scrapy，ScrapingHub，import io等。 本文简单讲解一下Scrapy的架构。没错，通用提取器gsExtractor就是要集成到Scrapy架构中。 请注意，本文不想复述原文内容，而是为了开源Python爬虫的发展方向找参照，而且以9年来开发网络爬虫经验作为对标，从而本文含有不少笔者主观评述，如果想读Scrapy官方原文，请点击Scrapy官网的Architecture。 scrapy数据流 Scrapy中的数据流由执行引擎控制，下面的原文摘自Scrapy官网，我根据猜测做了点评，为进一步开发GooSeeker开源爬虫指示方向： The Engine gets the first URLs to crawl from the Spider and schedules them in the Scheduler, as Requests. URL谁来准备呢？看样子是Spider自己来准备，那么可以猜测Scrapy架构部分（不包括Spider）主要做事件调度，不管网址的存储。看起来类似GooSeeker会员中心的爬虫罗盘，为目标网站准备一批网址，放在罗盘中准备执行爬虫调度操作。所以，这个开源项目的下一个目标是把URL的管理放在一个集中的调度库里面。 The Engine asks the Scheduler for the next URLs to crawl. 看到这里其实挺难理解的，要看一些其他文档才能理解透。接第1点，引擎从Spider中把网址拿到以后，封装成一个Request，交给了事件循环，会被Scheduler收来做调度管理的，暂且理解成对Request做排队。引擎现在就找Scheduler要接下来要下载的网页地址。 The Scheduler returns the next URLs to crawl to the Engine and the Engine sends them to the Downloader, passing through the Downloader Middleware (request direction). 从调度器申请任务，把申请到的任务交给下载器，在下载器和引擎之间有个下载器中间件，这是作为一个开发框架的必备亮点，开发者可以在这里进行一些定制化扩展。 Once the page finishes downloading the Downloader generates a Response (with that page) and sends it to the Engine, passing through the Downloader Middleware (response direction). 下载完成了，产生一个Response，通过下载器中间件交给引擎。注意，Response和前面的Request的首字母都是大写，虽然我还没有看其它Scrapy文档，但是我猜测这是Scrapy框架内部的事件对象，也可以推测出是一个异步的事件驱动的引擎，就像DS打数机的三级事件循环一样，对于高性能、低开销引擎来说，这是必须的。 The Engine receives the Response from the Downloader and sends it to the Spider for processing, passing through the Spider Middleware (input direction). 再次出现一个中间件，给开发者足够的发挥空间。 The Spider processes the Response and returns scraped items and new Requests (to follow) to the Engine. 每个Spider顺序抓取一个个网页，完成一个就构造另一个Request事件，开始另一个网页的抓取。 The Engine passes scraped items and new Requests returned by a spider through Spider Middleware (output direction), and then sends processed items to Item Pipelines and processed Requests to the Scheduler. 引擎作事件分发 The process repeats (from step 1) until there are no more requests from the Scheduler. 持续不断地运行。 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图形与文本处理一]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%80%2F</url>
      <content type="text"><![CDATA[java绘制图形和文本&lt;一&gt;开篇介绍(官方文档) java.awt类 Graphicsjava.lang.Object继承者 java.awt.Graphics直接已知子类：DebugGraphics, Graphics2Dpublic abstract class Graphics extends Object Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。Graphics 对象封装了 Java 支持的基本呈现操作所需的状态信息。此状态信息包括以下属性：要在其上绘制的 Component 对象。呈现和剪贴坐标的转换原点。当前剪贴区。当前颜色。当前字体。当前逻辑像素操作函数（XOR 或 Paint）。当前 XOR 交替颜色（参见 setXORMode(java.awt.Color)）。坐标是无限细分的，并且位于输出设备的像素之间。绘制图形轮廓的操作是通过使用像素大小的画笔遍历像素间无限细分路径的操作，画笔从路径上的锚点向下和向右绘制。填充图形的操作是填充图形内部区域无限细分路径操作。呈现水平文本的操作是呈现字符字形完全位于基线坐标之上的上升部分。图形画笔从要遍历的路径向下和向右绘制。其含义如下：如果绘制一个覆盖给定矩形的图形，那么该图形与填充被相同矩形所限定的图形相比，在右侧和底边多占用一行像素。如果沿着与一行文本基线相同的 y 坐标绘制一条水平线，那么除了文字的所有下降部分外，该线完全画在文本的下面。所有作为此 Graphics 对象方法的参数而出现的坐标，都是相对于调用该方法前的此 Graphics 对象转换原点的。所有呈现操作仅修改当前剪贴区所限定区域内的像素，此剪贴区是由用户空间中的 Shape 指定的，并通过使用 Graphics 对象的程序来控制。此用户剪贴区 被转换到设备空间中，并与设备剪贴区 组合，后者是通过窗口可见性和设备范围定义的。用户剪贴区和设备剪贴区的组合定义复合剪贴区，复合剪贴区确定最终的剪贴区域。用户剪贴区不能由呈现系统修改，以反映得到的复合剪贴区。用户剪贴区只能通过 setClip 或 clipRect 方法更改。所有的绘制或写入都以当前的颜色、当前绘图模式和当前字体完成。 绘制直线主要用到的内容是Graphics类中的drawLine函数定义： public abstract void drawLine(int x1,int y1,int x2,int y2)x1,y1是起始点的坐标，x2,y2是尾点的坐标 拓展 SetColor(Color color) setColor是Graphics类中的一个函数，主要是设置颜色作用，其中参数是Color类中的一个对象，用于定义自己的颜色，里面的变量的是RGB,定义的方法：Color color=newe Color(R,G,B) 代码 123456789101112131415161718192021222324252627282930 import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawLineFrame extends JFrame &#123; DrawLinePanel linePanel = new DrawLinePanel(); public static void main(String args[]) &#123; // 主函数 DrawLineFrame frame = new DrawLineFrame(); // 创建一个继承JFrame的一个类对象 frame.setVisible(true); // 设置窗体可见，true为可见，false为不可见 &#125; public DrawLineFrame() &#123; super(); setTitle("绘制直线"); // 设置窗体的标题 setBounds(100, 100, 273, 167); // 设置窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体的关闭方式，具体见官方文档 add(linePanel); // 将继承Jpanel类的容器对象添加在窗体中 &#125; class DrawLinePanel extends JPanel &#123; // 继承在JPanel类的一个内部类，用于定义直线 public void paint(Graphics g) &#123; // 重写JCommponent类中的paint方法，用来绘制直线 Color color=new Color(Color.Red);//这里用的是Color提供的颜色，当然读者也可以自己定义RGB颜色 g.setColor(Color);//将颜色作用于绘图上下文 g.drawLine(70, 50, 180, 50); // 调用方法 g.drawLine(70, 80, 180, 80); // 第二条直线 g.drawLine(110, 10, 140, 120); // 第三条 &#125; &#125;&#125; 绘制矩形主要用到的函数是：public abstract void drawRect(int x,int y,int width,int height)这里的x,y是矩形左上角的坐标，width，height是矩形的长和宽 拓展fillRect(int x,int y,int width,int height):绘制实心矩形 代码 1234567891011121314151617181920212223242526import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawRectangleFrame extends JFrame &#123;DrawRectanglePanel rectPanel = new DrawRectanglePanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawRectangleFrame frame = new DrawRectangleFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawRectangleFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制矩形"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(rectPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawRectanglePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawRect(30, 40, 80, 60); // 绘制空心矩形 g.fillRect(140, 40, 80, 60); // 绘制实心矩形 &#125;&#125;&#125; 绘制椭圆 函数：public abstract void drawOval(int x,int y,int width,int height),其中x,y是外切矩形的左上角的坐标，width，height是长宽 拓展 其中将令width=height，即是一个圆了，fillOval(int x,int y,int width,int height)用来绘制实心的椭圆 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawEllipseFrame extends JFrame &#123; DrawEllipsePanel ellipsePanel = new DrawEllipsePanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawEllipseFrame frame = new DrawEllipseFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawEllipseFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制椭圆"); // 窗体标题 setBounds(100, 100, 269, 222); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(ellipsePanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawEllipsePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawOval(30, 20, 80, 50); // 绘制空心椭圆 g.drawOval(150, 10, 50, 80); // 绘制空心椭圆 g.fillOval(40, 90, 50, 80); // 绘制实心椭圆 g.fillOval(140, 110, 80, 50); // 绘制实心椭圆 &#125; &#125; &#125; ``` &gt;&gt;## 绘制圆弧&gt;&gt;&gt;主要用到的函数`public astract void drawArc(int x,int y,int width,int height,int startAngle,int arcAngle)`，其中x,y是要绘制圆弧的左上角的坐标，width，height是要绘制的长宽，startAngle是开始角度，arcAngle是相对于开始角度而言的，弧跨越的角度，&gt;&gt;&gt;&gt;### 拓展:&gt;&gt;&gt;&gt;&gt;fillArc(int x,int y,int width,int height,int startAngle,int arcAngle)用来绘制实心圆弧&gt;&gt;&gt;&gt;&gt;当然你也可以用这个来绘制扇形，用drawLine方法将圆弧的两端连起来就可以了，不过这个对坐标的精确度就要求很高了，暂时不想费那个脑筋来搞了&gt;&gt;&gt;&gt;### 代码```java package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawArcFrame extends JFrame &#123; DrawArcPanel arcPanel = new DrawArcPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawArcFrame frame = new DrawArcFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawArcFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制圆弧"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(arcPanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawArcPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawArc(20, 20, 80, 80, 0, 120); // 绘制圆弧 g.drawArc(20, 40, 80, 80, 0, -120); // 绘制圆弧 g.drawArc(150, 20, 80, 80, 180, -120);// 绘制圆弧 g.drawArc(150, 40, 80, 80, 180, 120); // 绘制圆弧 &#125; &#125; &#125; 绘制多边形 主要用到的函数是：public abstract void drawPolygon(int[] xpoints,int[] ypoints,int npoints)，其中xpoints：要绘制多边形的x坐标组，ypoints是要绘制多边形的y坐标组，npoints是多边形的n条边 拓展 fillPolygon(...)是绘制实心多边形的函数 代码 1234567891011121314151617181920212223242526package com.zzk;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawSectorFrame extends JFrame &#123;DrawSectorPanel sectorPanel = new DrawSectorPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawSectorFrame frame = new DrawSectorFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawSectorFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制填充扇形"); // 窗体标题 setBounds(100, 100, 278, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(sectorPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawSectorPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.fillArc(40, 20, 80, 80, 0, 150); // 绘制填充扇形 g.fillArc(140, 20, 80, 80, 180, -150);// 绘制填充扇形 g.fillArc(40, 40, 80, 80, 0, -110); // 绘制填充扇形 g.fillArc(140, 40, 80, 80, 180, 110); // 绘制填充扇形 &#125;&#125;&#125; 绘制文本 主要用到的函数是：public abstract void drawString(String value,int x,int y),其中value是要绘制的文本，x,y是第一个字的坐标 拓展 SetFont(Font font):这个函数是用来设置文本的字体大小，颜色的，其中参数font是Font类中的 代码 12345678910111213141516171819202122232425262728293031323334353637package com.zzk;import java.awt.Font;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class TextFontFrame extends JFrame &#123;ChangeTextFontPanel changeTextFontPanel = new ChangeTextFontPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 TextFontFrame frame = new TextFontFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public TextFontFrame() &#123; super(); // 调用超类的构造方法 setTitle("设置文本的字体"); // 窗体标题 setBounds(100, 100, 333, 199); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(changeTextFontPanel); // 将面板类的实例添加到窗体容器中&#125;class ChangeTextFontPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 String value = "明日编程词典社区"; int x = 40; // 文本位置的横坐标 int y = 50; // 文本位置的纵坐标 Font font = new Font("华文行楷", Font.BOLD + Font.ITALIC, 26); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 value = "http://community.mrbccd.com"; x = 10; // 文本位置的横坐标 y = 100; // 文本位置的纵坐标 font = new Font("宋体", Font.BOLD, 20); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 &#125;&#125;&#125; 补充 字体样式包括Font.BLOD(粗体)，Font.ITALIC(斜体)，Font.PLAIN(普通字体)，其中如果要设置两种样式，可以用”+”连接，如：Font.BLOD+Font.ITALIC，这样就会同时设置了斜体和粗体样式 以上是本人的学习成果，通过不断的学习和探索，发现网上没有什么系统的学习java图形处理的文章，就下定决心准备好好写，于是前几天就花了一晚上的时间搭建了博客，以前都是在CSDN上写的，发现在那上面写，没有逼格，为了提高逼格，自己撸了一个博客，让我来自由发挥，另外喜欢编程的朋友可以加我的联系方式，我们可以一起探讨，在下面留言也是可以的哦,联系方式可以在我的关于我可以找到 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
  
  
</search>
